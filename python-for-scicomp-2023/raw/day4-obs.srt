1
00:00:00,000 --> 00:00:02,000
CodeRefinery.org

2
00:00:30,000 --> 00:00:32,060
you

3
00:01:00,000 --> 00:01:02,060
you

4
00:01:30,000 --> 00:01:32,060
you

5
00:02:00,000 --> 00:02:02,060
you

6
00:02:30,000 --> 00:02:59,560
I think you should be able to hear us on the stream.

7
00:02:59,560 --> 00:03:10,440
I can hear us on the stream, which I will now mute because the echo is, of course, annoying.

8
00:03:10,440 --> 00:03:14,380
So we put two icebreakers in here.

9
00:03:14,380 --> 00:03:18,680
What's the most surprising thing you've learned so far in this course and most surprising

10
00:03:18,680 --> 00:03:22,980
thing you've learned so far in your career?

11
00:03:22,980 --> 00:03:31,060
And if anyone has any other icebreaker ideas, please, well, you can also propose your own

12
00:03:31,060 --> 00:03:37,940
questions there.

13
00:03:37,940 --> 00:03:45,300
I'm trying to think of something specifically related to today's materials, which is a bit,

14
00:03:45,300 --> 00:03:52,300
we have a wide range of topics.

15
00:03:52,300 --> 00:04:03,980
Yeah, so what's our summary so far?

16
00:04:03,980 --> 00:04:09,580
Where have we come from and where did we go?

17
00:04:09,580 --> 00:04:16,380
We started with day 1, and it seemed like it was pretty normal Python stuff.

18
00:04:16,380 --> 00:04:22,520
Like Jupyter, NumPy, Pandas, I mean, doing Python code.

19
00:04:22,520 --> 00:04:29,500
Day 2 did we start getting exciting.

20
00:04:29,500 --> 00:04:36,020
So day 2 started pretty normal with Pandas and Matplotlib.

21
00:04:36,020 --> 00:04:44,500
again using normal Python code. Towards the end, we start seeing more interactions with the rest

22
00:04:44,500 --> 00:04:51,300
of the world. So the data formats emphasizing how it's not just about the code, but how you

23
00:04:52,340 --> 00:05:03,700
mess with this other, how you read and write data outside of Python can matter.

24
00:05:03,700 --> 00:05:10,020
And then, of course, the things like the linters and so on, which is user interface.

25
00:05:10,020 --> 00:05:15,340
But then yesterday, I mean, yesterday's the kind of stuff which is really important for

26
00:05:15,340 --> 00:05:19,980
using Python, but you wouldn't see in a typical course.

27
00:05:19,980 --> 00:05:29,180
So things like making the scripts, well, you might see that in a Python course, not a purely

28
00:05:29,180 --> 00:05:31,420
theoretical programming course.

29
00:05:31,420 --> 00:05:38,460
But yeah, the introduction to programming with Python

30
00:05:38,460 --> 00:05:39,700
might not even use Jupyter.

31
00:05:39,700 --> 00:05:43,180
It might use just scripts.

32
00:05:43,180 --> 00:05:46,860
And the library ecosystem independency management,

33
00:05:46,860 --> 00:05:55,500
well, that is, I mean, that's really

34
00:05:55,500 --> 00:05:58,180
getting to the kind of stuff which we use

35
00:05:58,180 --> 00:06:01,460
and we support people with on a daily basis.

36
00:06:01,460 --> 00:06:04,740
So my estimate has been that about half of our

37
00:06:04,740 --> 00:06:11,460
total support requests are helping to install software on the cluster,

38
00:06:11,460 --> 00:06:18,180
a lot of which is in Python and could, in theory, be done independently.

39
00:06:18,180 --> 00:06:23,060
But it's so confusing and hard.

40
00:06:23,060 --> 00:06:27,940
Dependencies are a complicated topic and a big unsolved problem.

41
00:06:27,940 --> 00:06:31,960
Um, it's also the reason, like all of these libraries, the fact that they

42
00:06:31,960 --> 00:06:33,780
exist is the reason why Python is good.

43
00:06:35,080 --> 00:06:40,820
I mean, the language itself is good, but the main reason people actually use it

44
00:06:40,820 --> 00:06:43,300
is because there are already all of these libraries available.

45
00:06:47,600 --> 00:06:49,280
Hello from my side as well.

46
00:06:49,340 --> 00:06:49,740
Yeah.

47
00:06:49,800 --> 00:06:56,140
Like I was just thinking myself at that, like, uh, quite often when, when using

48
00:06:56,140 --> 00:07:02,060
Python, it's more about reading what some other person has done like a package and then reading

49
00:07:02,060 --> 00:07:09,500
how they want you to use it and then just using it. And it's like, is this, can you call this

50
00:07:09,500 --> 00:07:14,620
even like coding when you're like calling functions from other libraries and that sort of

51
00:07:14,620 --> 00:07:22,940
stuff? But of course you are coding, but like, yeah. And, and, and, and using, using like, it

52
00:07:22,940 --> 00:07:30,380
would be wasteful to not use the capabilities provided by the other people.

53
00:07:31,660 --> 00:07:36,300
And it's usually the thing you find is not exactly the thing you want, but you can

54
00:07:37,100 --> 00:07:44,300
coax your data to fit into that and kind of use it or modify it slightly to make it what you want.

55
00:07:44,860 --> 00:07:52,140
Yeah. And it's like buying Lego blocks. You buy Lego blocks and then you have a world that you can

56
00:07:52,140 --> 00:07:57,500
create with them and you can of course like just follow the instructions and do the set that you

57
00:07:57,500 --> 00:08:05,580
have bought or whatever or you can go wild and do whatever you want with them like combine the blocks

58
00:08:05,580 --> 00:08:11,020
in an unexpected way and create something new and that's what like usually happens but you don't

59
00:08:11,020 --> 00:08:16,060
start molding the lego blocks yourself like that would be waste of time like getting like a 3d

60
00:08:16,060 --> 00:08:24,380
printer to mold them. Of course, if you want to, you can go to Python libraries and start

61
00:08:24,380 --> 00:08:28,700
writing C code and that sort of stuff, but then you're coding C code and you're not coding Python.

62
00:08:28,700 --> 00:08:39,020
So I think we need to do a volume check.

63
00:08:39,020 --> 00:08:46,980
So, well, let's start with an order, me, Simo, Yarno.

64
00:08:46,980 --> 00:08:47,980
1.

65
00:08:47,980 --> 00:08:48,980
1.

66
00:08:48,980 --> 00:08:49,980
1.

67
00:08:49,980 --> 00:08:50,980
2.

68
00:08:50,980 --> 00:08:51,980
2.

69
00:08:51,980 --> 00:08:52,980
2.

70
00:08:52,980 --> 00:08:53,980
3.

71
00:08:53,980 --> 00:08:54,980
3.

72
00:08:54,980 --> 00:08:55,980
3.

73
00:08:55,980 --> 00:08:56,980
Three.

74
00:08:56,980 --> 00:08:57,980
Three.

75
00:08:57,980 --> 00:09:01,420
So, I think Simo is too loud.

76
00:09:01,420 --> 00:09:09,700
I can also drop it here.

77
00:09:09,700 --> 00:09:13,060
I'm actually not at 100%.

78
00:09:13,060 --> 00:09:17,900
Is it better now?

79
00:09:17,900 --> 00:09:22,020
You still seem pretty loud.

80
00:09:22,020 --> 00:09:23,020
Better?

81
00:09:23,020 --> 00:09:24,020
One.

82
00:09:24,020 --> 00:09:25,020
Two.

83
00:09:25,020 --> 00:09:26,020
Sorry.

84
00:09:26,020 --> 00:09:27,020
Oh, yeah.

85
00:09:27,020 --> 00:09:28,020
One, one, one.

86
00:09:28,020 --> 00:09:29,020
Two.

87
00:09:29,020 --> 00:09:30,020
Two.

88
00:09:30,020 --> 00:09:31,020
Okay.

89
00:09:31,020 --> 00:09:32,020
Is this better?

90
00:09:32,020 --> 00:09:33,020
Okay.

91
00:09:33,020 --> 00:09:42,020
Might be just my enthusiasm rubbing off on you.

92
00:09:42,020 --> 00:09:43,020
Yeah.

93
00:09:43,020 --> 00:09:46,020
Might be just my enthusiasm rubbing off.

94
00:09:50,460 --> 00:09:52,300
Yeah.

95
00:09:52,300 --> 00:09:56,180
So I'm liking these icebreaker answers here.

96
00:09:56,180 --> 00:09:58,140
I just thought of these last minute,

97
00:09:58,140 --> 00:10:04,420
but it's good to see what's surprising in the course.

98
00:10:04,420 --> 00:10:08,580
And also, I like these career lessons also.

99
00:10:08,580 --> 00:10:20,040
So, last time there were some problems with a blurry screen, and one part might have been

100
00:10:20,040 --> 00:10:28,880
Twitch, but also it might have been so people are sharing by Zoom, and then I render it

101
00:10:28,880 --> 00:10:37,480
on the screen, and then capture it, and then it gets rebroadcasted.

102
00:10:37,480 --> 00:10:41,840
So there might be a little bit of blur that comes here.

103
00:10:41,840 --> 00:10:49,480
So if you see a problem, let me know, is it really bad or like a little bit of anti-aliasing

104
00:10:49,480 --> 00:10:54,720
around the letters and let us know right away and we'll try to fix that.

105
00:10:54,720 --> 00:10:55,720
Yeah.

106
00:10:55,720 --> 00:11:00,160
On your side, I recommend in the Twitch, there's like this cog icon at the bottom right of

107
00:11:00,160 --> 00:11:08,080
video where you can click the video quality and you can make it to appear as source quality,

108
00:11:08,080 --> 00:11:14,560
because otherwise it's automatic and then it might degrade it based on the network performance that

109
00:11:14,560 --> 00:11:21,280
you have. So you might like get suddenly a blurry flash because it's buffering or something like

110
00:11:21,280 --> 00:11:28,240
that. So setting it to force it to be the highest quality might mitigate some of the problems.

111
00:11:30,160 --> 00:11:39,560
Okay. Well, it's 10.01. Any comments from these surprising things or should we just

112
00:11:39,560 --> 00:11:47,800
go on? Should us instructors say the most surprising stuff? Maybe we should just go

113
00:11:47,800 --> 00:11:50,400
on. We can answer this in the panel discussion.

114
00:11:50,400 --> 00:11:51,400
Okay.

115
00:11:51,400 --> 00:11:56,480
In the wheel getting reinvented. But yeah, we'll talk about it. Well, at least we will

116
00:11:56,480 --> 00:11:59,080
talk about how to package your own stuff so that other people

117
00:11:59,080 --> 00:12:03,120
don't need to necessarily write it themselves later.

118
00:12:03,120 --> 00:12:06,640
But first, we have some parallel processing.

119
00:12:06,640 --> 00:12:08,600
OK, so I'll head out.

120
00:12:08,600 --> 00:12:09,800
Can you share the screen?

121
00:12:09,800 --> 00:12:13,680
Yeah, I can take the share if you capture it from my screen.

122
00:12:26,480 --> 00:12:27,480
Okay.

123
00:12:27,480 --> 00:12:30,480
I see it.

124
00:12:30,480 --> 00:12:31,480
Okay.

125
00:12:31,480 --> 00:12:32,480
Okay.

126
00:12:32,480 --> 00:12:35,480
I will head off.

127
00:12:35,480 --> 00:12:36,480
All right.

128
00:12:36,480 --> 00:12:37,480
See you.

129
00:12:37,480 --> 00:12:38,480
After.

130
00:12:38,480 --> 00:12:39,480
Okay.

131
00:12:39,480 --> 00:12:40,480
Are we ready?

132
00:12:40,480 --> 00:12:41,480
Yeah.

133
00:12:41,480 --> 00:12:42,480
Yeah.

134
00:12:42,480 --> 00:12:43,480
So okay.

135
00:12:43,480 --> 00:12:44,480
So the first thing I want to do is I want to run this.

136
00:12:44,480 --> 00:12:45,480
Okay.

137
00:12:45,480 --> 00:12:53,480
Okay, are we ready?

138
00:12:53,480 --> 00:12:54,480
Yeah.

139
00:12:54,480 --> 00:12:55,480
Yeah.

140
00:12:55,480 --> 00:12:56,480
So, okay.

141
00:12:56,480 --> 00:13:00,960
So, the first topic is parallel programming and that's kind of an interesting topic to

142
00:13:00,960 --> 00:13:06,400
talk about in Python and I mean, well, you'll see in a moment, but the main thing, I guess,

143
00:13:06,400 --> 00:13:14,520
in Python is that you are using, you're often using Python to connect packages written for

144
00:13:14,520 --> 00:13:19,720
you or written by someone else, and possibly written in other languages.

145
00:13:19,720 --> 00:13:24,200
The first thing when you start considering making your program faster, or especially

146
00:13:24,200 --> 00:13:29,900
if you start thinking about making it parallel, is to check if the libraries you're using

147
00:13:29,900 --> 00:13:33,400
already are parallel or not.

148
00:13:33,400 --> 00:13:37,440
That's probably the most important point of this lesson.

149
00:13:37,440 --> 00:13:41,120
If you come away with just one thing, that's it.

150
00:13:41,120 --> 00:13:49,720
But we will talk a bit about how parallel programming actually works, what it actually

151
00:13:49,720 --> 00:13:53,520
does and how it can or maybe cannot make your code faster.

152
00:13:53,520 --> 00:13:57,600
Sorry, I interrupted you, do you have something?

153
00:13:57,600 --> 00:14:00,880
No, no, no, go ahead.

154
00:14:00,880 --> 00:14:09,280
So maybe we can ask, I could ask, what do we mean when we talk about parallel?

155
00:14:09,280 --> 00:14:13,760
we mean when we talk about parallel programming? Is it like two people on a keyboard?

156
00:14:15,440 --> 00:14:21,040
Yeah, right. So that's called pair coding, I guess. That's a slightly different thing.

157
00:14:21,680 --> 00:14:28,000
Although that is actually a good, I think that's a pretty good metaphor for what the computer does

158
00:14:28,000 --> 00:14:33,120
or what the program does when you run it in parallel. So if you are writing some code

159
00:14:33,120 --> 00:14:39,080
code, and you want to do it twice as fast, hiring two programmers will make it faster,

160
00:14:39,080 --> 00:14:43,320
I guess, but it might not make it twice as fast.

161
00:14:43,320 --> 00:14:48,600
But yeah, so basically, the starting point, if you're thinking about making your code

162
00:14:48,600 --> 00:14:51,080
parallel, is that you want to make it run faster.

163
00:14:51,080 --> 00:14:54,200
It's taking too much time for one reason or another.

164
00:14:54,200 --> 00:15:01,120
Otherwise, you can just run it on a single processor and it will be done.

165
00:15:01,120 --> 00:15:03,520
So that's the starting point.

166
00:15:03,520 --> 00:15:05,120
We want to make it faster.

167
00:15:05,120 --> 00:15:10,440
If your program is fast enough, you don't need to make it parallel.

168
00:15:10,440 --> 00:15:15,120
Would you say that the speedup would come from utilizing multiple processors in one

169
00:15:15,120 --> 00:15:16,440
computer?

170
00:15:16,440 --> 00:15:22,560
Yes, so parallelization specifically, yeah.

171
00:15:22,560 --> 00:15:28,480
So you try to make it faster by essentially using multiple computers.

172
00:15:28,480 --> 00:15:32,480
There are multiple processors on most computers these days.

173
00:15:32,480 --> 00:15:35,480
Basically, if you have a laptop, desktop, you're watching this.

174
00:15:35,480 --> 00:15:43,480
It has 4, 6, 8, 12, maybe around 12 processors that are on the same chip,

175
00:15:43,480 --> 00:15:49,480
but are essentially running calculations independent of each other at the same time.

176
00:15:49,480 --> 00:15:55,400
So, yeah, so making your program parallel basically means all of those processes are

177
00:15:55,400 --> 00:16:01,240
doing something at the same time, so in parallel.

178
00:16:01,240 --> 00:16:02,560
Okay.

179
00:16:02,560 --> 00:16:09,080
So the first thing, though, if your code is too slow, you kind of want to do some, before

180
00:16:09,080 --> 00:16:14,720
going into parallel programming, because it can quickly become a complicated thing, is

181
00:16:14,720 --> 00:16:22,000
check why your code actually is slow, where are the slow spots, use some profiling tools

182
00:16:22,000 --> 00:16:28,560
and then think about can you use existing libraries or somehow make that part faster

183
00:16:29,600 --> 00:16:35,120
and then profile it again and see what part is slow now and so on and then when you get to the

184
00:16:35,120 --> 00:16:42,240
point where that's no longer helping you may think about parallel programming and then

185
00:16:42,240 --> 00:16:52,340
Then there are essentially two different modes of parallelism that people generally use

186
00:16:52,340 --> 00:16:59,620
and you can think about whether one or both of those will work actually in your program.

187
00:16:59,620 --> 00:17:04,360
So the first thing to check is if there is something that really needs to be running

188
00:17:04,360 --> 00:17:08,620
sequentially like you have to know the result of a previous computation to go to the next

189
00:17:08,620 --> 00:17:12,300
one, then you can't do those two things at the same time.

190
00:17:12,300 --> 00:17:14,020
So it's not really parallelizable.

191
00:17:14,300 --> 00:17:16,100
And then you just have to think of something else.

192
00:17:16,820 --> 00:17:22,180
Um, so there will be those parts in the code, but there will also be probably

193
00:17:22,180 --> 00:17:27,020
some parts in the code that were two calculations can be done at the same

194
00:17:27,020 --> 00:17:29,140
time, and then you can parallelize it.

195
00:17:30,260 --> 00:17:32,220
So, okay.

196
00:17:32,220 --> 00:17:36,860
So then like, and what do you say that like in some cases, like, let's say you

197
00:17:36,860 --> 00:17:42,480
have, you want to run the same code or multiple data sets or

198
00:17:42,480 --> 00:17:43,640
something like that you want.

199
00:17:43,640 --> 00:17:45,980
Yeah, so that's one example. So maybe you just want to run the

200
00:17:45,980 --> 00:17:50,480
same code for multiple different parameter values. So

201
00:17:50,480 --> 00:17:53,000
you have a bunch of files that you want to process. So that's

202
00:17:53,000 --> 00:17:57,320
an example of something embarrassingly parallel. Which

203
00:17:57,320 --> 00:18:00,720
is like, I mean, it's an interesting expression, but

204
00:18:00,740 --> 00:18:05,480
that's kind of the official term these days. So it's, the reason

205
00:18:05,480 --> 00:18:09,560
embarrassing is because you don't need to do anything to make it parallel. It just means

206
00:18:09,560 --> 00:18:15,240
you run multiple copies of the program on those different processors, on those different

207
00:18:15,240 --> 00:18:22,760
computers. You can do that by running the command multiple times or you can program it in some

208
00:18:23,560 --> 00:18:30,520
more fancy way to start multiple copies of the program. We will see ways of doing that,

209
00:18:30,520 --> 00:18:34,680
but I mean, there's many ways. Many languages do that.

210
00:18:35,240 --> 00:18:40,680
I would say that the embarrassingly parallel is usually like, if you notice that in your code,

211
00:18:40,680 --> 00:18:45,640
you happen to have a for loop at the outermost layer and inside the for loop, you have something

212
00:18:45,640 --> 00:18:51,160
that run a model or something. You know that you can basically take that for loop and run it

213
00:18:51,160 --> 00:18:57,800
outside of the program. So basically run multiple copies of that program. And that's why it's

214
00:18:57,800 --> 00:19:03,320
barely called parallelism. It's like, so embarrassingly parallel, you don't need any

215
00:19:03,320 --> 00:19:08,280
fancy structures to make it happen. So the main thing about this embarrassingly

216
00:19:08,280 --> 00:19:14,120
parallel category is that the different processes, the different copies of your program don't need

217
00:19:14,120 --> 00:19:18,600
to communicate at all. They just do their own thing. And when they finish, they finish,

218
00:19:18,600 --> 00:19:24,760
the others do not care. That's embarrassingly parallel. And that is the most common situation,

219
00:19:24,760 --> 00:19:29,640
I think that's that's what you will usually end up doing. I just run the same thing many times

220
00:19:29,640 --> 00:19:35,320
but if that's not possible then there's two other options. There's multi-threading.

221
00:19:36,040 --> 00:19:40,200
Multi-threading means that they are running on the same computer but on different

222
00:19:40,920 --> 00:19:47,560
processors on that computer so essentially the thing is that they can share memory.

223
00:19:47,560 --> 00:19:55,880
when you have a variable in the program's memory, the other copies, so-called copies,

224
00:19:55,880 --> 00:19:59,720
or which are called threads really, they have access to that memory.

225
00:20:01,240 --> 00:20:06,520
So that makes things a bit easier. That makes sharing information between the processes a bit

226
00:20:06,520 --> 00:20:14,040
easier. And then there is message passing or MPI, message passing interface is a

227
00:20:14,040 --> 00:20:19,960
common term people use. And a common framework for this. So that means you have a bunch of

228
00:20:19,960 --> 00:20:25,960
independent processes that can be running on different computers and then they send messages

229
00:20:25,960 --> 00:20:33,880
to each other. They communicate over some kind of network. Or in Python you also have this

230
00:20:33,880 --> 00:20:41,000
multi-processing and what it basically means is that Python launches multiple processes and then

231
00:20:41,000 --> 00:20:48,760
they communicate by writing small files into memory, and then each process reads the files.

232
00:20:48,760 --> 00:20:55,080
But basically, it launches multiple Python interpreters that each run stuff.

233
00:20:56,200 --> 00:21:07,080
Yeah, so that's a Python-specific thing that is important, and we'll talk about

234
00:21:07,080 --> 00:21:12,360
multiprocessing in a moment. I'm kind of, well, we'll come back to it because I'm kind of struggling

235
00:21:12,360 --> 00:21:20,520
with a way of going in. Check the first example of Parallel. Yeah, okay. So if you go down a bit,

236
00:21:20,520 --> 00:21:25,320
there's the multithreading example. So this is still like relatively straightforward,

237
00:21:25,320 --> 00:21:33,480
especially in Python because essentially Python doesn't do multithreading, but the libraries that

238
00:21:33,480 --> 00:21:41,080
are written for Python can do multi-threading. So if you're using NumPy, SciPy, Pandas, and so on,

239
00:21:42,600 --> 00:21:47,800
they will be using libraries in the back end that are already multi-threaded.

240
00:21:48,920 --> 00:21:55,480
So basically, you don't need to do all that much. Just make sure you're not running a for loop in

241
00:21:55,480 --> 00:22:04,760
Python, but rather you are using a NumPy operation if you can. There are complicated enough NumPy

242
00:22:04,760 --> 00:22:10,440
operations that you can do most things without a Python for loop. For the technical side,

243
00:22:10,440 --> 00:22:17,560
people who want to know how it works, basically NumPy inside it has lots of libraries or it uses

244
00:22:17,560 --> 00:22:23,240
lots of libraries like this linear algebra libraries. Also, if you think about a for

245
00:22:23,240 --> 00:22:29,320
loop. It's like sum all values in this array or something like that. There's a for loop

246
00:22:30,520 --> 00:22:37,640
in many of the NumPy functions, and those for loops have been threaded in NumPy itself.

247
00:22:38,360 --> 00:22:44,440
If you just tell NumPy to use multiple processors, whenever you use the NumPy functions,

248
00:22:44,440 --> 00:22:51,240
it will try to run these for loops in parallel. It works behind the scenes, so the only thing

249
00:22:51,240 --> 00:23:01,240
you need to tell it is this OMP number of threads, which is a pretty cryptic variable,

250
00:23:01,240 --> 00:23:05,160
but basically what it tells is that use multiple processors.

251
00:23:05,160 --> 00:23:12,040
And this is also MKL and a third possible option. Usually, those are already set so that you don't

252
00:23:12,680 --> 00:23:19,080
need to set them. Usually, NumPy will just use multiple threads. You will see that by

253
00:23:19,080 --> 00:23:25,400
if you run NumPy and check what your processor load is, that Python process will be using something

254
00:23:25,400 --> 00:23:33,480
like 400 or 800 percent of a CPU. So that means it's already running on multiple processors.

255
00:23:33,480 --> 00:23:37,880
Threading is also common for web applications and that sort of thing, but because they're not,

256
00:23:38,440 --> 00:23:46,440
well, for scientific computing they are not so relevant. We won't be going to that, but

257
00:23:46,440 --> 00:23:54,040
But there's like Python has lots of these async things, but they are not relevant.

258
00:23:54,040 --> 00:24:00,600
So I'll just mention it, but if you see parallel using that, they are basically mainly for

259
00:24:00,600 --> 00:24:03,020
web applications and that sort of thing.

260
00:24:03,020 --> 00:24:09,000
So one big thing kind of worth mentioning, like if you are trying to do multi-threading

261
00:24:09,000 --> 00:24:12,800
on your own, I said Python doesn't do it.

262
00:24:12,800 --> 00:24:15,520
So it's, in fact, something that was kind of a choice that

263
00:24:15,520 --> 00:24:18,800
was made when the Python language was developed

264
00:24:18,800 --> 00:24:20,720
or is being developed.

265
00:24:20,720 --> 00:24:23,480
So there's something called a global interpreter lock.

266
00:24:23,480 --> 00:24:27,160
And basically, that means that there can only ever

267
00:24:27,160 --> 00:24:31,360
be one thread, one process running Python code.

268
00:24:31,360 --> 00:24:36,320
So if you want to run Python code,

269
00:24:36,320 --> 00:24:38,620
like have multiple processes running your Python code,

270
00:24:38,620 --> 00:24:42,680
you actually need to start multiple Python interpreters,

271
00:24:42,680 --> 00:24:45,180
which is exactly what the next thing will do.

272
00:24:45,180 --> 00:24:46,300
So this is a way around.

273
00:24:46,300 --> 00:24:48,580
Multiprocessing is a Python library,

274
00:24:48,580 --> 00:24:53,000
and it's a way around this issue.

275
00:24:53,000 --> 00:24:56,060
So if you actually find that whatever libraries

276
00:24:56,060 --> 00:24:59,540
you are using are not multitreaded,

277
00:24:59,540 --> 00:25:02,240
so you're not doing calculations in NumPy,

278
00:25:03,220 --> 00:25:05,980
or you are doing something a bit more complicated in Python

279
00:25:05,980 --> 00:25:08,620
and you know that you need to kind of split it

280
00:25:08,620 --> 00:25:10,180
into multiple processes,

281
00:25:10,180 --> 00:25:12,320
multiprocessing is a way to do it.

282
00:25:12,680 --> 00:25:18,080
There's a bunch of nice libraries built upon multiprocessing that might be more useful,

283
00:25:18,080 --> 00:25:25,900
but well, I guess we'll write a list into the notes in a moment, but here we'll just

284
00:25:25,900 --> 00:25:26,900
try to use multiprocessing.

285
00:25:26,900 --> 00:25:33,080
Yeah, let's check on, like, I can run the demo here and see what happens.

286
00:25:33,080 --> 00:25:34,920
So here we have an example.

287
00:25:34,920 --> 00:25:40,280
So we have a function.

288
00:25:40,280 --> 00:25:45,080
So we have a function that – well, maybe you can explain and I can write.

289
00:25:45,080 --> 00:25:46,080
Well, yeah.

290
00:25:46,080 --> 00:25:48,800
If you type – I mean, this is a very simple function.

291
00:25:48,800 --> 00:25:53,860
It just calculates the square of the number that you put in.

292
00:25:53,860 --> 00:25:57,960
But this is a Python function on purpose, so we're assuming that it's somehow something

293
00:25:57,960 --> 00:26:00,920
we cannot do in NumPy directly.

294
00:26:00,920 --> 00:26:11,080
And then map will run that function on every number in the list that you give it.

295
00:26:11,080 --> 00:26:15,620
So you notice it gives you the squares of every number.

296
00:26:15,620 --> 00:26:20,920
So one squared is one, two squared is four, and so on, six squared is 36.

297
00:26:20,920 --> 00:26:27,240
That was really fast because it's a small list, but it was running pure Python code,

298
00:26:27,240 --> 00:26:30,200
If it was a big list, it would be a lot slower than, say, numpy.

299
00:26:31,480 --> 00:26:38,360
I'll mention here that this might look, for those people who haven't used functional programming

300
00:26:38,360 --> 00:26:48,280
kind of things, this might look a bit strange, but it's basically like a for loop in a small space.

301
00:26:48,280 --> 00:26:54,280
It is running the same function to every element in the list.

302
00:26:54,280 --> 00:27:05,480
Yeah, you might see a more Pythonic version might be something like this.

303
00:27:07,160 --> 00:27:08,280
Yeah, okay, that's the same.

304
00:27:08,840 --> 00:27:11,240
Yeah, this is basically like a map function.

305
00:27:11,240 --> 00:27:11,960
Yeah.

306
00:27:11,960 --> 00:27:13,080
Yeah, that's a good example.

307
00:27:13,080 --> 00:27:20,920
Yeah, but basically it's the same thing, but using these maps makes sense when we go to the

308
00:27:20,920 --> 00:27:27,000
The reason we use the map function there, demonstrated, is because multiprocessing comes

309
00:27:27,000 --> 00:27:30,120
with its own version of the map function.

310
00:27:30,120 --> 00:27:39,280
So if you now import pool from multiprocessing and then pool contains the map function.

311
00:27:39,280 --> 00:27:41,760
Oh, okay.

312
00:27:41,760 --> 00:27:45,120
It's from multiprocessing input pool, not with.

313
00:27:45,120 --> 00:27:46,120
Oops.

314
00:27:46,120 --> 00:27:47,120
Yeah.

315
00:27:47,120 --> 00:27:48,120
My mistake.

316
00:27:48,120 --> 00:27:49,120
Was looking ahead already.

317
00:27:49,120 --> 00:27:50,120
Yeah.

318
00:27:50,120 --> 00:27:56,060
And then, yeah, then you need to get a pool or yeah, create a pool.

319
00:27:58,760 --> 00:28:02,300
So, so what we have, there's a great way of, of, or a great

320
00:28:02,300 --> 00:28:05,720
explanation of why this is called pool, but it's essentially a set of like.

321
00:28:06,340 --> 00:28:11,260
So it gives you a set of processors that you can use to run stuff.

322
00:28:11,620 --> 00:28:14,420
So you can run this square function with multiple processes.

323
00:28:15,540 --> 00:28:17,620
Um, it didn't actually return anything.

324
00:28:17,620 --> 00:28:20,420
I guess you have to probably need to store it somewhere.

325
00:28:20,620 --> 00:28:20,920
Yeah.

326
00:28:25,920 --> 00:28:26,220
Yeah.

327
00:28:27,320 --> 00:28:27,720
Okay.

328
00:28:28,320 --> 00:28:32,220
So yeah, this does the same thing and you didn't see the

329
00:28:32,220 --> 00:28:34,120
speed up of course because it's so fast.

330
00:28:34,120 --> 00:28:37,820
Anyway, we could have a much bigger list and then you would

331
00:28:37,820 --> 00:28:38,220
see it.

332
00:28:38,220 --> 00:28:43,520
But so what the multiprocessing pool does it it takes the

333
00:28:43,520 --> 00:28:47,520
list it splits it up between all the processors available.

334
00:28:47,620 --> 00:28:57,620
and then runs this function on all of those processes to some part of the work, basically.

335
00:28:58,580 --> 00:29:05,140
Yeah, and in general, I would say, here we give a list to it, but map basically works on any kind

336
00:29:05,140 --> 00:29:10,820
of iterable thing. So in Python, you see a lot of these iterable things, like something that

337
00:29:11,380 --> 00:29:16,020
at least is an iterable thing, but you can have other things as well, like iterators.

338
00:29:16,020 --> 00:29:22,500
And what map does is basically take something from the iterator and it runs a function on it.

339
00:29:22,500 --> 00:29:28,020
And if you use the normal map function in Python, you do it one by one in one processor,

340
00:29:28,020 --> 00:29:33,860
basically. But here we have a processor pool. So, we have multiple processors.

341
00:29:35,620 --> 00:29:41,540
Usually the number is decided to be the number of processors in your computer. Of course,

342
00:29:41,540 --> 00:29:47,780
you can set it yourself. But you have a number of processors, and we read from the iterator,

343
00:29:47,780 --> 00:29:53,060
and then we give each processor one at a time.

344
00:29:53,060 --> 00:29:53,940
Send those one by one to the different processors.

345
00:29:53,940 --> 00:29:54,660
Yeah.

346
00:29:54,660 --> 00:29:59,380
Or really, actually, many at a time, because sending one number is not efficient.

347
00:29:59,380 --> 00:30:03,860
Yes, many at a time. Of course, the multiprocessing library then collects the

348
00:30:03,860 --> 00:30:11,460
results in the same order back so that you get the same kind of correspondence between the input

349
00:30:11,460 --> 00:30:19,060
and the output but but basically now you do the mapping in parallel. Okay so let's now go to the

350
00:30:19,060 --> 00:30:28,500
exercise so there's an exercise one where you use multiprocessing and then you can also move

351
00:30:28,500 --> 00:30:37,300
on to exercise two which is more of a discussion about running on a cluster. So a cluster is a

352
00:30:37,300 --> 00:30:47,260
a supercomputer. It's a system with a lot of computers in a fast network. But yeah,

353
00:30:47,260 --> 00:30:56,020
mainly do exercise one, and then if you have extra time, take a look at exercise two.

354
00:30:56,020 --> 00:31:01,020
So we'll have 15 minutes for it.

355
00:31:01,020 --> 00:31:07,580
During the exercise we'll try to answer any unanswered questions in the notes and we'll

356
00:31:09,180 --> 00:31:16,300
bring them up after the if there's anything interesting or any especially good questions

357
00:31:16,300 --> 00:31:24,780
we'll raise them up. Okay, so that's it for now. See you in 15 minutes. Bye. Bye.

358
00:31:31,020 --> 00:31:33,080
you

359
00:32:01,020 --> 00:32:03,080
you

360
00:32:31,020 --> 00:32:33,080
you

361
00:33:01,020 --> 00:33:03,080
you

362
00:33:31,020 --> 00:33:33,080
you

363
00:34:01,020 --> 00:34:03,080
you

364
00:34:31,020 --> 00:34:33,080
you

365
00:35:01,020 --> 00:35:03,080
you

366
00:35:31,020 --> 00:35:33,080
you

367
00:36:01,020 --> 00:36:03,080
you

368
00:36:31,020 --> 00:36:33,080
you

369
00:37:01,020 --> 00:37:03,080
you

370
00:37:31,020 --> 00:37:33,080
you

371
00:38:01,020 --> 00:38:03,080
you

372
00:38:31,020 --> 00:38:33,080
you

373
00:39:01,020 --> 00:39:03,080
you

374
00:39:31,020 --> 00:39:33,080
you

375
00:40:01,020 --> 00:40:03,080
you

376
00:40:31,020 --> 00:40:33,080
you

377
00:41:01,020 --> 00:41:03,080
you

378
00:41:31,020 --> 00:41:33,080
you

379
00:42:01,020 --> 00:42:03,080
you

380
00:42:31,020 --> 00:42:33,080
you

381
00:43:01,020 --> 00:43:03,080
you

382
00:43:31,020 --> 00:43:33,080
you

383
00:44:01,020 --> 00:44:03,080
you

384
00:44:31,020 --> 00:44:33,080
you

385
00:45:01,020 --> 00:45:03,080
you

386
00:45:31,020 --> 00:46:00,060
Hey welcome back. So yeah there was one more thing we wanted to mention before MPI.

387
00:46:01,020 --> 00:46:14,020
Which is that a lot of the libraries, like we mentioned in the beginning, a lot of the libraries have some sort of parallelism built in, usually multi-threading.

388
00:46:14,020 --> 00:46:19,020
And often it just works out of the box.

389
00:46:19,020 --> 00:46:27,020
But also there are ways of setting the number of workers and using parallelism through some settings.

390
00:46:27,020 --> 00:46:37,020
So, yeah, it's usually usually a good idea to use this like the developers of the packages they have most likely tested that this parallelism actually speeds up the code.

391
00:46:37,020 --> 00:46:48,020
So, instead of like making some parallelism outside of what the developers have intended, using their method is most likely the most efficient way of getting parallelism.

392
00:46:48,020 --> 00:46:54,460
So, for example, like just like an example library that you might encounter is like a

393
00:46:54,460 --> 00:46:55,460
ski kit learn.

394
00:46:55,460 --> 00:47:02,100
If you're doing like machine learning or data analysis and that sort of stuff, putting models

395
00:47:02,100 --> 00:47:03,100
there.

396
00:47:03,100 --> 00:47:06,780
And let's say we are in the user guide, we just go to the user guide.

397
00:47:06,780 --> 00:47:11,100
Like this is what, like when people ask about parallelism, this is what I usually do.

398
00:47:11,100 --> 00:47:17,260
I open the packet space and then I press control F to search and then I search for parallel

399
00:47:17,260 --> 00:47:21,040
And there's like a page on parallelism here.

400
00:47:21,100 --> 00:47:25,460
And if we look at here, they mentioned that they're using this job lib library,

401
00:47:25,520 --> 00:47:28,680
which is similar to, or it's built upon multi-processing.

402
00:47:28,720 --> 00:47:29,560
It's a nice library.

403
00:47:29,560 --> 00:47:35,380
We'll mention other tools like this in the notes after the MPI session.

404
00:47:35,960 --> 00:47:42,480
But basically it says that there's this end jobs parameter, like on estimators

405
00:47:42,480 --> 00:47:46,800
that you can like, you can put it there and then it uses parallelism basically.

406
00:47:46,800 --> 00:47:52,260
And then you can, you also use this, uh, this higher level

407
00:47:52,260 --> 00:47:55,020
parallelism and these open MP stuff.

408
00:47:55,020 --> 00:48:00,820
And they have various ways they explain, like, uh, how do you get the best performance?

409
00:48:01,140 --> 00:48:05,700
So it's usually a good idea to check, check the guide, whether it's parallel

410
00:48:05,700 --> 00:48:11,040
mentioned anything parallel is the magic world, uh, word usually, uh, that, that

411
00:48:11,040 --> 00:48:12,840
can be found in various documentations.

412
00:48:12,840 --> 00:48:16,840
And you can then use that.

413
00:48:16,840 --> 00:48:22,840
Another thing that in the notes, I think it's good to mention.

414
00:48:22,840 --> 00:48:32,840
So at least one person got an error that from multiprocessing,

415
00:48:32,840 --> 00:48:37,840
that it cannot pickle the object something.

416
00:48:37,840 --> 00:48:43,840
something. And that happens because, like we mentioned, Python actually doesn't allow

417
00:48:43,840 --> 00:48:51,160
multiple processes, so they cannot actually just read memory or read the same memory.

418
00:48:51,160 --> 00:48:58,060
So what multiprocessing does to get around this is that it essentially writes the function

419
00:48:58,060 --> 00:49:04,120
and everything it needs to run that function to disk, starts another Python process, and

420
00:49:04,120 --> 00:49:08,960
And then that Python process reads it from the disk or if it's like if the disk can be

421
00:49:08,960 --> 00:49:09,960
on RAM.

422
00:49:09,960 --> 00:49:17,760
So the file can be in fast memory, but still it needs to be possible to write it to disk.

423
00:49:17,760 --> 00:49:23,040
And that the main thing is that that causes some restrictions.

424
00:49:23,040 --> 00:49:29,520
So sometimes things just don't work and there's ways of getting around this.

425
00:49:29,520 --> 00:49:33,880
You can read the instructions or try to ask people, but it gets a bit complicated.

426
00:49:33,880 --> 00:49:39,320
And in general, let's say you have a function that does really complex things and that sort of

427
00:49:39,320 --> 00:49:44,040
thing. If you want to run it in parallel, all of the different parallel processes need to know

428
00:49:44,040 --> 00:49:49,080
about that function and what the function has eaten. If it uses global variables or whatever,

429
00:49:49,080 --> 00:49:55,640
all of that needs to be transferred to that other process. So the more complex your parallel thing

430
00:49:55,640 --> 00:50:02,760
is, the harder it is usually to parallelize. So usually it's a good idea to parallelize.

431
00:50:02,760 --> 00:50:08,360
Yeah, keep it simple. Have a simple function that will be executed in Parallel and then

432
00:50:08,360 --> 00:50:11,720
return to a bigger program or something like that.

433
00:50:11,720 --> 00:50:18,760
So basically, if it's a method of a class, it needs the entire class. If it uses a global

434
00:50:18,760 --> 00:50:24,800
variable, it needs the entire file. And if you're calling multiprocessing from that same

435
00:50:24,800 --> 00:50:30,440
file, it will just fail. So one way around this often is to just move the function that

436
00:50:30,440 --> 00:50:34,280
you're running into a different file and often that will help but sometimes not.

437
00:50:34,280 --> 00:50:37,800
So just be aware of that.

438
00:50:37,800 --> 00:50:42,800
It gets complicated and try to use parallelism from inside the existing libraries rather

439
00:50:42,800 --> 00:50:45,840
than writing your own if possible.

440
00:50:45,840 --> 00:50:55,040
Now MPI though is usually not built into the libraries for a very important reason which

441
00:50:55,040 --> 00:51:04,760
is that it always needs to be run with this MPI run program, basically, that sets up an

442
00:51:04,760 --> 00:51:06,960
environment for.

443
00:51:06,960 --> 00:51:14,140
So what MPI does, it runs completely separate processes and then tells them some information

444
00:51:14,140 --> 00:51:17,200
about the other processes so that they can communicate.

445
00:51:17,200 --> 00:51:21,440
So these can be running on completely different parts of completely different computers as

446
00:51:21,440 --> 00:51:25,580
As long as they know the IP address to the other computer and there's an Ethernet cable

447
00:51:25,580 --> 00:51:29,400
or Wi-Fi connection or something, so that they can communicate.

448
00:51:29,400 --> 00:51:34,300
Of course, that would be quite slow if you send a lot of information back and forth.

449
00:51:34,300 --> 00:51:37,400
In principle, that is something you can do.

450
00:51:37,400 --> 00:51:44,580
So MPI is a very different paradigm because you just run copies of the program.

451
00:51:44,580 --> 00:51:47,280
All the copies run everything from the beginning.

452
00:51:47,280 --> 00:51:51,160
All the copies run all of your code, basically.

453
00:51:51,160 --> 00:51:56,120
the main difference. Whereas in multiprocessing, it just takes the function and tries to put it in

454
00:51:56,120 --> 00:52:03,560
a file and read that file and run it. With MPI, all of the copies will run everything unless you

455
00:52:03,560 --> 00:52:10,680
tell them specifically to not do that. There are other frameworks as well that work in a similar way

456
00:52:10,680 --> 00:52:17,000
that they basically set up some network configuration and they do their own configuration.

457
00:52:17,000 --> 00:52:22,840
For example, PyTorch has a Torch run, and there's Ray, which is this parallel library as well.

458
00:52:22,840 --> 00:52:27,880
But there's many frameworks that do this. Everybody starts, and then they just know

459
00:52:27,880 --> 00:52:36,920
about where the others are. They communicate in some way. In MPI's case, the MPI will handle this,

460
00:52:36,920 --> 00:52:42,680
okay, who are you? Where are you? But in many other cases, you might have master processes

461
00:52:42,680 --> 00:52:45,240
and clients connecting to the server.

462
00:52:45,240 --> 00:52:49,520
So for MPI, I mean, MPI is kind of the lowest level.

463
00:52:49,520 --> 00:52:52,280
It's kind of the basis, again, like multiprocessing

464
00:52:52,280 --> 00:52:55,640
is the basis of a lot of libraries.

465
00:52:55,640 --> 00:52:58,280
MPI also is the basis for a lot of stuff.

466
00:52:58,280 --> 00:53:01,280
So, okay, so we'll just show a quick example,

467
00:53:01,280 --> 00:53:03,400
but this is something you may not be able to run

468
00:53:03,400 --> 00:53:06,080
because it requires that you install

469
00:53:06,080 --> 00:53:07,440
not just the Python library,

470
00:53:07,440 --> 00:53:12,440
but also you need to install,

471
00:53:12,440 --> 00:53:21,400
like MPI as a system-level library. It's not written in Python. So it's possible to do it in

472
00:53:21,400 --> 00:53:26,600
Conda, but we don't assume that you have done that. You can try. Maybe you have the functions

473
00:53:26,600 --> 00:53:35,240
or not. Okay, so what Simo is doing here is first importing MPI for Pi, and then there's some magic

474
00:53:35,240 --> 00:53:40,440
stuff that, I mean, yeah, I could explain what those things are doing. But the main thing is that

475
00:53:40,440 --> 00:53:46,980
that, you get the size, which is the number of processors that are running this program.

476
00:53:46,980 --> 00:53:56,260
And then you get the rank, which is the unique identifier for this particular copy. It's

477
00:53:56,260 --> 00:54:03,980
a number from zero to size, basically. So that's what you have to work with, really.

478
00:54:03,980 --> 00:54:11,020
have a single number that identifies this particular copy and then there are MPI functions

479
00:54:11,020 --> 00:54:14,900
that allow you to send information to other copies. You have to know the number of the

480
00:54:14,900 --> 00:54:22,060
other copy. So from these building blocks, you can build a lot of stuff, of course, but

481
00:54:22,060 --> 00:54:23,060
it takes a bit of work.

482
00:54:23,060 --> 00:54:24,060
Yeah.

483
00:54:24,060 --> 00:54:31,620
Okay, so let's just try this. So this is just printing the rank, the identifier number and

484
00:54:31,620 --> 00:54:34,460
the number of processes.

485
00:54:34,460 --> 00:54:39,740
And to run an MPI program, you need to use MPI run.

486
00:54:39,740 --> 00:54:41,740
And you can give it a number.

487
00:54:41,740 --> 00:54:42,740
Okay.

488
00:54:42,740 --> 00:54:47,620
Well, I gave it the wrong name.

489
00:54:47,620 --> 00:54:50,620
Oh, yes.

490
00:54:50,620 --> 00:54:56,060
You need to give it the correct program, it will run better.

491
00:54:56,060 --> 00:54:59,220
If you try to run the wrong program, it will not run as well.

492
00:54:59,220 --> 00:55:00,220
Yeah, yeah.

493
00:55:00,220 --> 00:55:02,220
That's a good hint.

494
00:55:02,220 --> 00:55:04,220
Okay, so yeah.

495
00:55:04,220 --> 00:55:06,220
So it ran two copies of the program,

496
00:55:06,220 --> 00:55:08,220
one of them has identifier 1

497
00:55:08,220 --> 00:55:10,220
and the other one has identifier 0.

498
00:55:10,220 --> 00:55:12,220
So if you were, for example,

499
00:55:12,220 --> 00:55:14,220
doing what we were doing previously,

500
00:55:14,220 --> 00:55:16,220
where you split

501
00:55:16,220 --> 00:55:18,220
this list into

502
00:55:18,220 --> 00:55:20,220
two multiple processes,

503
00:55:20,220 --> 00:55:22,220
you would need to have

504
00:55:22,220 --> 00:55:24,220
perhaps just, usually you just

505
00:55:24,220 --> 00:55:26,220
set it up with

506
00:55:26,220 --> 00:55:28,220
process number 0 and then you

507
00:55:28,220 --> 00:55:32,720
send a part of you. You actually have to write manually write the code to send the part

508
00:55:32,720 --> 00:55:40,460
of the list to the other process. We'll do a different example. Let's just let's just

509
00:55:40,460 --> 00:55:46,980
run the example in the notes. It has all of the stuff that we just ran, but it's also

510
00:55:46,980 --> 00:55:56,300
yeah, like the different so yeah, okay. So the different identify the different processes

511
00:55:56,300 --> 00:56:00,780
are now doing a different thing, and in the end, it's being collected.

512
00:56:00,780 --> 00:56:07,340
Yeah, so all of this code, what's important in the code basically, we have the function

513
00:56:07,340 --> 00:56:16,420
that all of them will run independently and all of them will do their own part of the

514
00:56:16,420 --> 00:56:23,300
whole thing, but the important part is here in the line 39, where we have this communication

515
00:56:23,300 --> 00:56:29,700
gather so basically we gather everything and then we have this root so we gather all of that

516
00:56:29,700 --> 00:56:36,980
information to the processor zero so you can have this kind of like collective everybody

517
00:56:36,980 --> 00:56:43,220
send the information to the process zero and the process zero will then print. So that's an example

518
00:56:43,220 --> 00:56:47,700
of one of these functions that allow the processes to communicate with each other.

519
00:56:47,700 --> 00:56:55,100
There's also a send, for example, that just means one process sends information to one

520
00:56:55,100 --> 00:56:58,100
other process.

521
00:56:58,100 --> 00:57:02,060
Okay.

522
00:57:02,060 --> 00:57:07,020
I guess we probably don't want to go too much into detail about this because we also

523
00:57:07,020 --> 00:57:11,220
want to spend some time on all the rest of the material.

524
00:57:11,220 --> 00:57:12,220
Yeah.

525
00:57:12,220 --> 00:57:16,500
I'll quickly mention that the MPI is commonly used in scientific codes and that sort of

526
00:57:16,500 --> 00:57:24,100
where you might have a grid or collective, like you can't solve some problem in a big grid or

527
00:57:24,100 --> 00:57:29,700
something like that, where everybody talks to their neighbors. But the communication,

528
00:57:29,700 --> 00:57:36,100
how do you communicate? It depends heavily on the problem. So you need to usually provide the

529
00:57:36,100 --> 00:57:44,100
communication. Who tells who what information? Based on your problem, you usually need to

530
00:57:44,100 --> 00:57:48,140
to decide yourself how to do it.

531
00:57:48,140 --> 00:57:50,940
So there's one big rule of thumb

532
00:57:50,940 --> 00:57:53,500
when it comes to multi-threading or multi-processing

533
00:57:53,500 --> 00:57:57,180
and MPI, which is because multi-threading

534
00:57:57,180 --> 00:57:59,980
and multi-processing usually run a very small path,

535
00:57:59,980 --> 00:58:02,780
like a single for loop in parallel,

536
00:58:02,780 --> 00:58:06,420
whereas MPI will run all of the code in parallel.

537
00:58:06,420 --> 00:58:11,420
So in MPI, you want to split at the highest level possible.

538
00:58:11,420 --> 00:58:19,420
So as much as possible get split between the processes and then they're just like occasionally sending messages to each other.

539
00:58:19,420 --> 00:58:28,420
In multi-threading, basically you want to parallelize the smallest loop or one loop at a time.

540
00:58:28,420 --> 00:58:38,420
So they tend to be used quite differently and that's also the reason why often the libraries are parallelized with this multi-threading,

541
00:58:38,420 --> 00:58:44,500
multiprocessing things and not with MPI, but if you're using MPI then you usually have to do it

542
00:58:44,500 --> 00:58:56,340
yourself or use something that's specifically intended with MPI. Okay, so another thing is,

543
00:58:56,340 --> 00:59:04,500
like we said, a lot of libraries are using multithreading and the reason they can do

544
00:59:04,500 --> 00:59:11,300
it efficiently is because they're not written in Python. Python needs to use a multi-processing

545
00:59:11,300 --> 00:59:18,260
approach because one process can only run at a time. But in C, C++, Fortran, whatever,

546
00:59:19,860 --> 00:59:26,500
in all of these fast compiled languages, you can run multiple threads at a time.

547
00:59:27,300 --> 00:59:34,260
Multiple threads can run code at the same time. Almost everything is written, has a back end

548
00:59:34,500 --> 00:59:42,740
that runs the fast parts using libraries written in these languages.

549
00:59:43,780 --> 00:59:48,340
So if you ended up in a situation where you need to kind of extend those libraries a bit,

550
00:59:49,220 --> 00:59:59,780
there's multiple ways of writing C, C++ code for Rust and then calling that from Python

551
00:59:59,780 --> 01:00:02,780
to get the thing done.

552
01:00:02,780 --> 01:00:04,780
Yeah, there are also...

553
01:00:04,780 --> 01:00:06,780
You can just call your library from Python.

554
01:00:06,780 --> 01:00:08,780
There are also like Python libraries

555
01:00:08,780 --> 01:00:11,780
such as Numba and Jax nowadays

556
01:00:11,780 --> 01:00:13,780
that can do stuff like

557
01:00:13,780 --> 01:00:15,780
just-in-time compilation

558
01:00:15,780 --> 01:00:17,780
where they like take your Python function

559
01:00:17,780 --> 01:00:19,780
and then they compile it

560
01:00:19,780 --> 01:00:21,780
into a faster C++ function

561
01:00:21,780 --> 01:00:23,780
without you ever leaving Python.

562
01:00:23,780 --> 01:00:25,780
But they are...

563
01:00:25,780 --> 01:00:27,780
They need additional things usually

564
01:00:27,780 --> 01:00:35,220
things usually. Your code needs to be written in a way that it can be compiled, not be like

565
01:00:35,220 --> 01:00:41,300
generic Python code. It doesn't exactly support general Python. It's a subset of Python that you

566
01:00:41,300 --> 01:00:46,340
have to use, but it allows you to write the program, write the function in Python and then

567
01:00:47,140 --> 01:00:51,780
run it as if it was written in C, which is really convenient and usually actually the

568
01:00:51,780 --> 01:00:58,660
first thing you would want to do or try. Yeah. And before we leave for a break,

569
01:01:00,660 --> 01:01:07,540
we can mention Dusk as well. So if you're dealing with big pandas data frames,

570
01:01:07,540 --> 01:01:12,020
if you have a lot of data that you need to process, Dusk is this kind of

571
01:01:12,020 --> 01:01:19,820
of like improvement on pandas or more parallelizable version

572
01:01:19,820 --> 01:01:24,500
of pandas that allows the probe, like what it does basically

573
01:01:24,500 --> 01:01:27,820
is that when you set in your pandas code or whatever,

574
01:01:27,820 --> 01:01:32,220
you select certain rows here, calculate average of them,

575
01:01:32,220 --> 01:01:36,780
and whatever, you have some operations that you do.

576
01:01:36,780 --> 01:01:40,020
Dusk can create this kind of like a computational graph

577
01:01:40,020 --> 01:01:47,460
of it and then it can execute it in parallel. So let's say it will run like the data in pieces

578
01:01:47,460 --> 01:01:52,580
or something like that and it can handle the parallelism on the back end. And if you're

579
01:01:52,580 --> 01:02:01,460
dealing with large data sets like big data sets of data frames, it's a very useful tool and it's

580
01:02:01,460 --> 01:02:07,300
used in like banks and that sort of stuff because it makes it possible to analyze like huge amounts

581
01:02:07,300 --> 01:02:11,700
of, let's say, customer data or something.

582
01:02:11,700 --> 01:02:19,020
So I started a list of useful libraries for parallel Python libraries, and I wrote that

583
01:02:19,020 --> 01:02:20,980
the task is useful for large data sets.

584
01:02:20,980 --> 01:02:27,540
There's also JobLabel, which is, I guess, an easier way of doing maps with multiprocessing.

585
01:02:27,540 --> 01:02:34,700
I guess it probably does other things as well.

586
01:02:34,700 --> 01:02:43,700
Yes, so we'll continue adding more stuff there, and if you have any more questions, just put them in the notes.

587
01:02:43,700 --> 01:02:53,700
Yeah, and please add any library you know of or you use that we may not know of yet, because that's always good to keep up to date.

588
01:02:53,700 --> 01:03:00,260
Yeah, and also if you, at the end of the day, if you have some certain cases that you would

589
01:03:00,260 --> 01:03:04,060
want us to present or certain libraries you would want us to present in the coming years,

590
01:03:04,060 --> 01:03:10,380
let us know, because there's so many of these nowadays, so it's hard to say what are the

591
01:03:10,380 --> 01:03:13,900
most important ones for our users.

592
01:03:13,900 --> 01:03:18,180
But what sort of use cases you want us to demonstrate.

593
01:03:18,180 --> 01:03:22,860
Otherwise, so we intentionally left a good amount of time for discussion here.

594
01:03:22,860 --> 01:03:33,940
So I'm looking for questions in the notes that we might want to bring up.

595
01:03:33,940 --> 01:03:37,500
There's a good question there, how can I install OpenMPI?

596
01:03:37,500 --> 01:03:42,640
Well, Conda has an OpenMPI installation package there in it.

597
01:03:42,640 --> 01:03:50,580
So you can just Conda install OpenMPI, at least from Conda Forge, and MPF API as well.

598
01:03:50,580 --> 01:03:53,460
that's, I would highly recommend using that compared to like

599
01:03:53,460 --> 01:03:57,740
installing an MPI by yourself, unless you're using it in a very

600
01:03:57,740 --> 01:04:00,600
large scenario in a computational cluster or

601
01:04:00,600 --> 01:04:04,060
something. But if you want to work in in like one machine or

602
01:04:04,060 --> 01:04:09,900
something like that, the MPI in the in Conda is good, good

603
01:04:09,900 --> 01:04:13,940
enough in most cases, like, or if you have a, if you're working

604
01:04:13,940 --> 01:04:17,900
in a computational cluster, the maintenance of that cluster

605
01:04:17,900 --> 01:04:20,300
will usually provide you with an MPI already,

606
01:04:20,300 --> 01:04:24,100
because it needs extra stuff to be able to do it.

607
01:04:24,100 --> 01:04:27,100
There will probably be multiple versions you can choose from.

608
01:04:30,420 --> 01:04:33,180
Another one, so this is answered in the notes,

609
01:04:33,180 --> 01:04:35,740
but benchmarking libraries,

610
01:04:35,740 --> 01:04:38,420
because we talked a good bit in the beginning

611
01:04:38,420 --> 01:04:41,020
about how before thinking about parallelizing,

612
01:04:41,020 --> 01:04:43,540
you should do benchmarking and try to just make the code

613
01:04:43,540 --> 01:04:45,420
faster with the existing libraries,

614
01:04:45,420 --> 01:04:48,420
which is usually enough.

615
01:04:48,420 --> 01:04:55,420
So if you have one specific function you know you want to benchmark,

616
01:04:55,420 --> 01:04:58,420
then timeit is a really good library.

617
01:04:58,420 --> 01:05:03,420
And if you have an entire code,

618
01:05:03,420 --> 01:05:06,420
or when you're starting you basically just have one entire code,

619
01:05:06,420 --> 01:05:11,420
you want to figure out what is the slow part in that code,

620
01:05:11,420 --> 01:05:13,420
then scalene is a good option.

621
01:05:13,420 --> 01:05:22,540
So, that's on this question, mark this question number nine, but should we, is it easy to

622
01:05:22,540 --> 01:05:23,540
find in notes?

623
01:05:23,540 --> 01:05:28,420
Yeah, I added to the libraries list.

624
01:05:28,420 --> 01:05:30,420
Okay, good.

625
01:05:30,420 --> 01:05:39,420
So, it's benchmarking and yeah.

626
01:05:39,420 --> 01:05:40,420
Yeah.

627
01:05:44,420 --> 01:05:48,420
Guidelines for deciding knowing in what way I should parallelize my code.

628
01:05:51,420 --> 01:05:56,420
I would say like the first thing is like check out the embarrassingly parallel.

629
01:05:56,420 --> 01:06:07,420
That's usually the most efficient way of parallelization because it's like if you have a natural thing in your code.

630
01:06:07,420 --> 01:06:15,900
code that is embarrassingly parallelizable. For example, you run it with multiple parameters,

631
01:06:15,900 --> 01:06:20,940
multiple datasets, and that is usually the way to go because that scales infinitely, basically,

632
01:06:20,940 --> 01:06:25,340
because you can always launch more processes. As long as you have more data, right?

633
01:06:25,340 --> 01:06:30,780
Yeah, as long as you have more data. Yeah. And after that, I would say probably check

634
01:06:30,780 --> 01:06:33,820
the libraries that you're using, whether they support parallelization.

635
01:06:33,820 --> 01:06:40,220
But yeah, so then if a single case just takes too long to run, like several days,

636
01:06:41,500 --> 01:06:45,580
so if you're running on a cluster or on a supercomputer, you can usually reserve it

637
01:06:45,580 --> 01:06:51,820
for a few days. But then if something breaks, you might lose everything. So it's important to

638
01:06:51,820 --> 01:06:59,180
build in some checkpointing. So write everything to disk so that if you have to restart it,

639
01:06:59,180 --> 01:07:07,500
it can continue from where it was. That's already very useful. It's not parallelization exactly,

640
01:07:07,500 --> 01:07:15,500
but it just allows you to run for longer. Then if it still takes way too long,

641
01:07:18,300 --> 01:07:21,500
then you just need to make it faster and you might need to parallelize in some way.

642
01:07:21,500 --> 01:07:37,500
And then, if there's a way of splitting the data, like if you're running a simulation with a grid of points, you can split those points and run independently for each of those points.

643
01:07:37,500 --> 01:07:41,500
That's a good case for MPI, possibly.

644
01:07:41,500 --> 01:07:53,500
if you have big loops over a lot of small things inside those you might be able to parallelize with multi-threading options.

645
01:07:53,500 --> 01:08:01,500
So basically though, well the multi-threading thing basically means use libraries that are multi-threaded,

646
01:08:01,500 --> 01:08:13,980
multithreaded, which means NumPy, SciPy, Torch, TensorFlow, whatever. It depends on what you're

647
01:08:13,980 --> 01:08:21,660
doing, but almost everything is multithreaded if it does a lot of calculations. So just

648
01:08:21,660 --> 01:08:27,260
try to combine calls to NumPy, for example. If you have multiple calls to NumPy with the

649
01:08:27,260 --> 01:08:34,380
same data, try to make it one call so that it doesn't get split.

650
01:08:34,380 --> 01:08:40,420
One thing also, there's a few questions in the chat about the multiprocessing example,

651
01:08:40,420 --> 01:08:48,220
like locking up. It might be due to the Jupyter locking the GL, the global interpreter lock,

652
01:08:48,220 --> 01:08:53,940
what we were talking about. Because if you have a Jupyter, you have a JupyterLab running

653
01:08:53,940 --> 01:08:59,780
Python interpreter, and then you try to run multiprocessing there, it might be that the

654
01:08:59,780 --> 01:09:06,140
Jupyter and how it processes the sales and that sort of thing, it should work, but there

655
01:09:06,140 --> 01:09:11,700
might be a situation where it somehow locks the global interpreter lock.

656
01:09:11,700 --> 01:09:16,500
So that might happen, but it's hard to say.

657
01:09:16,500 --> 01:09:18,620
We will check the examples and we will verify that.

658
01:09:18,620 --> 01:09:20,900
There's at least two questions about this.

659
01:09:20,900 --> 01:09:21,900
Yeah.

660
01:09:21,900 --> 01:09:22,900
So we'll verify.

661
01:09:22,900 --> 01:09:23,900
Yeah.

662
01:09:23,900 --> 01:09:29,820
solution, like if you take the solution from the web page and it doesn't work, then it

663
01:09:29,820 --> 01:09:35,500
might be, yeah, you might want to check compared to the solution.

664
01:09:35,500 --> 01:09:42,700
Okay. We are out of time though. So let's take a break and then we'll move on to packaging.

665
01:09:42,700 --> 01:09:48,420
Yeah. I'll quickly mention that there was also like a question about pooling, like

666
01:09:48,420 --> 01:09:56,820
pool one getting bad results or like using pool was worse than not using pool. And this is

667
01:09:56,820 --> 01:10:02,660
exactly what might happen in a case where you parallelize a thing that actually doesn't benefit

668
01:10:02,660 --> 01:10:08,260
from parallelization. So the example of course is like a trivial example that we have. So it's a

669
01:10:08,260 --> 01:10:15,060
very low, like the processor will just go through it in an instant anyways. Like it's going to be

670
01:10:15,060 --> 01:10:22,180
like nanoseconds or microseconds or something to calculate it. So adding the constructions of,

671
01:10:22,180 --> 01:10:29,780
okay, we'll construct a parallel pool and then we'll give everyone their own process to run,

672
01:10:29,780 --> 01:10:36,340
it's a huge amount of overhead. But the thing happens is that when we are getting to the

673
01:10:36,340 --> 01:10:44,180
runtimes of seconds or minutes, then suddenly the overhead isn't that big. But usually you need to

674
01:10:44,180 --> 01:10:50,660
figure out what is the part in the code that requires me to parallelize it.

675
01:10:52,420 --> 01:11:00,180
And usually, also, I'll mention that, for example, the map thing, writing it as a NumPy array and

676
01:11:00,180 --> 01:11:05,700
just squaring the NumPy array would be much faster than any pooling because NumPy already

677
01:11:05,700 --> 01:11:11,380
does the parallelization inside. So, not using Python objects, but using NumPy arrays would be

678
01:11:11,380 --> 01:11:17,060
always faster than doing the pooling thing. So it's a trivial example, but it's just to

679
01:11:17,060 --> 01:11:23,780
demonstrate how to use the tools. Okay. But yeah, so we are out of time. So

680
01:11:26,420 --> 01:11:34,340
do take a break and walk around a bit. Let's come back in 10 minutes. All right. Bye.

681
01:11:34,340 --> 01:11:35,860
Bye.

682
01:11:41,380 --> 01:11:43,440
you

683
01:12:11,380 --> 01:12:13,440
you

684
01:12:41,380 --> 01:12:43,440
you

685
01:13:11,380 --> 01:13:13,440
you

686
01:13:41,380 --> 01:13:43,440
you

687
01:14:11,380 --> 01:14:13,440
you

688
01:14:41,380 --> 01:14:43,440
you

689
01:15:11,380 --> 01:15:13,440
you

690
01:15:41,380 --> 01:15:43,440
you

691
01:16:11,380 --> 01:16:13,440
you

692
01:16:41,380 --> 01:16:43,440
you

693
01:17:11,380 --> 01:17:13,440
you

694
01:17:41,380 --> 01:17:43,440
you

695
01:18:11,380 --> 01:18:13,440
you

696
01:18:41,380 --> 01:18:43,440
you

697
01:19:11,380 --> 01:19:13,440
you

698
01:19:41,380 --> 01:19:43,440
you

699
01:20:11,380 --> 01:20:13,440
you

700
01:20:41,380 --> 01:20:43,440
you

701
01:21:11,380 --> 01:21:25,240
Hello.

702
01:21:25,240 --> 01:21:48,200
Hello. I hope everyone had a good break and is refreshed after 10 minutes. So, let's go

703
01:21:48,200 --> 01:21:51,400
to packaging.

704
01:21:51,400 --> 01:21:54,040
And yeah, we talked about all the different libraries

705
01:21:54,040 --> 01:21:56,360
in the Python ecosystem.

706
01:21:56,360 --> 01:22:00,720
Now we are going to add one, or at least add one

707
01:22:00,720 --> 01:22:04,340
into the test thing, but show you

708
01:22:04,340 --> 01:22:06,360
how to create your own package and how

709
01:22:06,360 --> 01:22:10,880
to publish your own code, or at least make it easy for you

710
01:22:10,880 --> 01:22:14,760
to use across all of your projects.

711
01:22:14,760 --> 01:22:21,480
So should we do some talking first or just jump directly in?

712
01:22:21,480 --> 01:22:22,600
I would jump in.

713
01:22:22,600 --> 01:22:24,120
Or why are we doing it?

714
01:22:27,000 --> 01:22:30,000
Yeah, I guess the main thing is to make it easy for you

715
01:22:30,000 --> 01:22:32,000
to use your code.

716
01:22:32,000 --> 01:22:33,680
If you have a piece of code that you

717
01:22:33,680 --> 01:22:36,800
want to use in multiple projects,

718
01:22:36,800 --> 01:22:39,000
make it easy for you to do that.

719
01:22:39,000 --> 01:22:40,960
And just have it all in one place

720
01:22:40,960 --> 01:22:43,240
where you can maintain that bit.

721
01:22:43,240 --> 01:22:45,480
well, you can just maintain it in one place.

722
01:22:45,480 --> 01:22:47,240
Or even to get it to the point

723
01:22:47,240 --> 01:22:49,680
where other people can use your code

724
01:22:49,680 --> 01:22:52,200
and only one person still has to maintain it,

725
01:22:52,200 --> 01:22:55,760
which is, it saves time.

726
01:22:55,760 --> 01:22:57,720
Other people might even be maintaining your code

727
01:22:57,720 --> 01:22:59,260
at some point.

728
01:22:59,260 --> 01:23:02,320
I'd actually say that is probably the most important point

729
01:23:02,320 --> 01:23:03,640
for packaging in the end,

730
01:23:03,640 --> 01:23:06,760
that you make it easy for other people to use it.

731
01:23:06,760 --> 01:23:07,600
Yeah.

732
01:23:07,600 --> 01:23:09,780
So that it is actually used.

733
01:23:09,780 --> 01:23:10,620
Yes.

734
01:23:10,620 --> 01:23:17,620
So, what do we need to make a Python package?

735
01:23:17,620 --> 01:23:22,620
Well, we need some structure.

736
01:23:22,620 --> 01:23:28,620
Well, yeah. There needs to be some structure that everybody knows is going to be there.

737
01:23:28,620 --> 01:23:33,620
And that's basically kind of predefined.

738
01:23:33,620 --> 01:23:42,260
There will be modules because a Python file is called a module so you will have code in

739
01:23:42,260 --> 01:23:52,340
Python files and then we collect related modules into packages and in here we will

740
01:23:52,340 --> 01:23:58,980
show how to collect them into a package. Then if you want other people to be able to use your code

741
01:23:58,980 --> 01:24:03,860
you need a license. That's also if you want to accept contributions from anyone else you

742
01:24:03,860 --> 01:24:11,620
need a license because they need to give you the access to use the code and that the license file

743
01:24:11,620 --> 01:24:16,420
is usually in the root of the project the root folder of the project. You need a readme file

744
01:24:16,420 --> 01:24:22,020
because you need to tell people what the code is and what it does. It's also good to have

745
01:24:22,020 --> 01:24:26,980
other documentation but often in a small project or when you're starting readme is enough

746
01:24:26,980 --> 01:24:35,380
documentation but it's also good to have other documentation and automated testing is great

747
01:24:35,380 --> 01:24:41,220
because it allows you to check that everything works well at least like the things you are

748
01:24:41,220 --> 01:24:47,540
testing work by just running one command. And it helps you a lot in staying backward

749
01:24:47,540 --> 01:24:52,820
compatible so that what you're changing doesn't change for earlier results. Yeah,

750
01:24:52,820 --> 01:24:56,460
Yeah, that's very important, very useful.

751
01:24:56,460 --> 01:25:00,060
Okay, so those are the things we'll cover.

752
01:25:00,060 --> 01:25:02,940
I'm actually not sure if we cover testing.

753
01:25:02,940 --> 01:25:04,460
Well, let's see.

754
01:25:04,460 --> 01:25:07,900
But first we'll start with creating a package.

755
01:25:07,900 --> 01:25:10,900
So we'll assume that we have some useful functions

756
01:25:10,900 --> 01:25:14,140
we have written that we want to use in other projects.

757
01:25:15,300 --> 01:25:18,100
So the first of them is add.

758
01:25:19,620 --> 01:25:22,220
Yeah, imagine that this is a useful function.

759
01:25:22,220 --> 01:25:26,060
So this will add two numbers together.

760
01:25:26,060 --> 01:25:26,780
Here we are.

761
01:25:26,780 --> 01:25:28,100
OK, great.

762
01:25:28,100 --> 01:25:38,700
Let's also write a subtract.pi, or subtracting.pi,

763
01:25:38,700 --> 01:25:40,780
which will subtract two numbers from each other.

764
01:25:40,780 --> 01:25:55,740
Okay, and finally, one thing that's slightly more complicated, which will do a numerical

765
01:25:55,740 --> 01:25:56,740
integral.

766
01:25:56,740 --> 01:26:06,820
You are cheating a bit, we don't really write the code, we just use a library.

767
01:26:06,820 --> 01:26:08,780
Well, yes, but you should not write the code

768
01:26:08,780 --> 01:26:09,900
for a numerical integral.

769
01:26:09,900 --> 01:26:12,780
You should use SciPy.

770
01:26:12,780 --> 01:26:14,380
So there's one question.

771
01:26:14,380 --> 01:26:16,580
Can you do this packaging in JupyterLab?

772
01:26:16,580 --> 01:26:19,700
So you can write the code in JupyterLab.

773
01:26:19,700 --> 01:26:21,820
You can create the files in JupyterLab.

774
01:26:21,820 --> 01:26:25,900
So almost everything we do, you can do in JupyterLab.

775
01:26:25,900 --> 01:26:29,500
But it is, at least for me, we're

776
01:26:29,500 --> 01:26:33,580
dealing with the file system more than with Python code.

777
01:26:33,580 --> 01:26:36,460
So it's kind of more natural to do it here.

778
01:26:40,220 --> 01:26:41,620
You can also, so, okay.

779
01:26:41,620 --> 01:26:46,180
So the point is Jupyter is more made for, I guess, notebooks

780
01:26:46,180 --> 01:26:47,780
and the packaging part,

781
01:26:47,780 --> 01:26:49,940
like it's about creating Python files

782
01:26:49,940 --> 01:26:53,040
and running commands in terminal.

783
01:26:53,040 --> 01:26:54,940
So you can do it in Jupyter.

784
01:26:54,940 --> 01:26:58,000
It's fine, but it's not using notebooks.

785
01:26:58,860 --> 01:26:59,700
Sorry, Richard.

786
01:26:59,700 --> 01:27:04,260
Thomas, can you make your fonts bigger?

787
01:27:04,260 --> 01:27:09,260
Is that big enough?

788
01:27:09,260 --> 01:27:11,900
Well, probably good.

789
01:27:11,900 --> 01:27:13,980
We can see what people say.

790
01:27:13,980 --> 01:27:14,980
I think it's probably good.

791
01:27:14,980 --> 01:27:19,660
I probably can't change them in the editor, at least not quickly.

792
01:27:19,660 --> 01:27:23,980
Yeah, the editor will probably follow the terminal font.

793
01:27:23,980 --> 01:27:25,400
Let's see.

794
01:27:25,400 --> 01:27:29,460
Can you run ls just to see what's in the current directory now?

795
01:27:29,460 --> 01:27:34,980
So yeah, we have some Python modules that are useful and we want to use in other places.

796
01:27:34,980 --> 01:27:39,460
I think for now, if you scroll down in the notes a little bit, you'll see a general structure

797
01:27:39,460 --> 01:27:42,140
for a package or what the folder could look like.

798
01:27:42,140 --> 01:27:50,760
I think the first thing we want to do is to create a folder where we put all the modules.

799
01:27:50,760 --> 01:27:53,540
So this will essentially be like, this is the Python stuff.

800
01:27:53,540 --> 01:27:59,500
This is the thing that's called a package.

801
01:27:59,500 --> 01:28:01,500
So this is where all the Python code goes.

802
01:28:01,500 --> 01:28:03,280
And it's a folder.

803
01:28:03,280 --> 01:28:10,140
It's just a normal folder, and we just move all of the .py files there.

804
01:28:10,140 --> 01:28:15,540
So do you want us to start here with the project?

805
01:28:15,540 --> 01:28:19,580
So is this what we're currently looking at, the project folder for our example?

806
01:28:19,580 --> 01:28:21,360
example?

807
01:28:21,360 --> 01:28:23,380
I mean, OK, so you created a folder that

808
01:28:23,380 --> 01:28:25,180
will be the project rules.

809
01:28:25,180 --> 01:28:25,680
OK.

810
01:28:25,680 --> 01:28:27,180
OK, so let's just go there.

811
01:28:27,180 --> 01:28:33,500
And then there we create another folder that's the package.

812
01:28:33,500 --> 01:28:37,460
I'll just push all of this over so that we.

813
01:28:37,460 --> 01:28:39,860
So this is a very common structure in Q.

814
01:28:39,860 --> 01:28:41,420
We are back in here, but.

815
01:28:41,420 --> 01:28:44,220
Yeah, so now let's create another folder.

816
01:28:44,220 --> 01:28:47,100
So basically, the reason for this

817
01:28:47,100 --> 01:28:50,460
is we want to have one thing we can import.

818
01:28:50,460 --> 01:28:53,620
Like, when you import NumPy, you import all of NumPy.

819
01:28:53,620 --> 01:28:55,940
We want to import calculator and be

820
01:28:55,940 --> 01:28:58,740
able to import all of these functions at once.

821
01:28:58,740 --> 01:29:03,100
But now, actually, we can't quite do that yet.

822
01:29:03,100 --> 01:29:07,100
What we can do now is run from calculator import adding,

823
01:29:07,100 --> 01:29:09,060
for example.

824
01:29:09,060 --> 01:29:11,940
But we need to tell what Python needs to do when

825
01:29:11,940 --> 01:29:13,380
we want to import calculator.

826
01:29:13,380 --> 01:29:20,880
And we do that by adding this __init__.py.

827
01:29:20,880 --> 01:29:25,020
That's something that it's kind of predefined in Python.

828
01:29:25,020 --> 01:29:30,820
And it is what turns a folder into a Python package.

829
01:29:30,820 --> 01:29:37,420
So here you can import things that you

830
01:29:37,420 --> 01:29:41,460
want to be imported when you import this package.

831
01:29:43,380 --> 01:29:45,300
And this is just normal Python code, really.

832
01:29:45,300 --> 01:29:50,380
So actually, what happens is when you import calculator,

833
01:29:50,380 --> 01:29:54,660
when you import this folder or this package,

834
01:29:54,660 --> 01:30:00,300
it will run this code that Umesh is now typing.

835
01:30:00,300 --> 01:30:06,020
And everything that's then defined in this Python code,

836
01:30:06,020 --> 01:30:09,460
all of that will appear as calculator.something.

837
01:30:09,460 --> 01:30:13,620
So there will be calculator.add, calculator.subtract,

838
01:30:13,620 --> 01:30:17,300
and calculator.integral, and also calculator.version

839
01:30:17,300 --> 01:30:20,220
with the underscores.

840
01:30:20,220 --> 01:30:23,340
OK, so this looks good.

841
01:30:23,340 --> 01:30:27,300
Should we now try importing it just to see?

842
01:30:27,300 --> 01:30:29,100
Or, well, yeah, let's import it first,

843
01:30:29,100 --> 01:30:32,180
and then we'll add a license and readme.

844
01:30:32,180 --> 01:30:33,620
I hope I started the environment.

845
01:30:33,620 --> 01:30:34,140
Let's see.

846
01:30:34,140 --> 01:30:43,140
Well, right now, it's all in this folder, so you don't actually need to be in the environment.

847
01:30:43,140 --> 01:30:45,140
SciPy isn't, potentially.

848
01:30:45,140 --> 01:30:48,140
Oh, SciPy might not be there. That's true.

849
01:30:48,140 --> 01:31:00,140
Well, if you try to import Calculator, if there's no SciPy, can you run...

850
01:31:00,140 --> 01:31:04,620
run so okay you just run from calculator can you run import calculator

851
01:31:10,460 --> 01:31:18,380
no module name calculator is it yeah it has an init file oh uh wait

852
01:31:22,700 --> 01:31:27,180
i'm not entirely sure but i think well okay let's see

853
01:31:27,180 --> 01:31:28,180
Okay.

854
01:31:28,180 --> 01:31:29,180
Nope.

855
01:31:29,180 --> 01:31:30,180
Interesting.

856
01:31:30,180 --> 01:31:32,460
Did you actually move to the folder?

857
01:31:32,460 --> 01:31:34,020
Can you type ls?

858
01:31:34,020 --> 01:31:35,020
Okay.

859
01:31:35,020 --> 01:31:36,020
I'm in the wrong folder.

860
01:31:36,020 --> 01:31:37,020
Yes.

861
01:31:37,020 --> 01:31:38,020
You are in the wrong folder.

862
01:31:38,020 --> 01:31:39,020
Okay.

863
01:31:39,020 --> 01:31:40,020
Okay.

864
01:31:40,020 --> 01:31:45,180
So now you can import calculator and you have SciPy.

865
01:31:45,180 --> 01:31:46,180
Yep.

866
01:31:46,180 --> 01:31:48,620
So it didn't actually, it didn't fail.

867
01:31:48,620 --> 01:31:49,620
All right.

868
01:31:49,620 --> 01:31:54,020
So yeah, that's why we add this init.py and that's why we have all of these files in a

869
01:31:54,020 --> 01:31:55,420
single folder.

870
01:31:55,420 --> 01:31:59,980
You can, of course, you can have a more nested structure with multiple folders, but the init.py

871
01:31:59,980 --> 01:32:04,060
makes this a package.

872
01:32:04,060 --> 01:32:09,860
And then, well, you can also try, you can do from calculator import add.

873
01:32:09,860 --> 01:32:17,580
This actually, actually this does require an input.py, yeah, okay.

874
01:32:17,580 --> 01:32:18,580
Seems to work.

875
01:32:18,580 --> 01:32:21,580
Yeah, seems to be doing things.

876
01:32:21,580 --> 01:32:26,660
So let's exit this interpreter, or if you

877
01:32:26,660 --> 01:32:29,020
want to try something else, fine.

878
01:32:29,020 --> 01:32:31,060
Try an integral or something.

879
01:32:31,060 --> 01:32:32,860
OK, yeah, let's exit the interpreter.

880
01:32:32,860 --> 01:32:37,300
And now we don't have a license file or a readme file.

881
01:32:37,300 --> 01:32:41,100
So we don't need to decide on a license for this test case,

882
01:32:41,100 --> 01:32:47,580
but let's just create the file and a readme file as well.

883
01:32:47,580 --> 01:32:48,980
Let's just create them for now.

884
01:32:51,580 --> 01:32:52,580
Yeah.

885
01:32:52,580 --> 01:32:53,580
They are empty.

886
01:32:53,580 --> 01:32:54,580
Okay.

887
01:32:54,580 --> 01:32:55,580
So, yeah.

888
01:32:55,580 --> 01:32:56,580
Now we have two empty files.

889
01:32:56,580 --> 01:32:59,580
If you don't, press again to show what we have.

890
01:32:59,580 --> 01:33:00,580
Okay.

891
01:33:00,580 --> 01:33:03,980
So, we have calculator, we have license, and readme.

892
01:33:03,980 --> 01:33:08,580
Now, the next thing to make this a package, oh, what is the time?

893
01:33:08,580 --> 01:33:09,580
22.

894
01:33:09,580 --> 01:33:11,580
22 passed.

895
01:33:11,580 --> 01:33:12,580
Okay.

896
01:33:12,580 --> 01:33:24,580
So, yeah, so the next thing we need to add to make this package installable is this piproject.toml.

897
01:33:24,580 --> 01:33:31,740
And yeah, just create a file and we'll just copy the stuff from the example.

898
01:33:31,740 --> 01:33:33,740
And this is what I do anyway.

899
01:33:33,740 --> 01:33:39,980
Like when I start a project, I copy a piproject.toml from somewhere and then I modify it according

900
01:33:39,980 --> 01:33:42,540
to like my needs.

901
01:33:42,540 --> 01:33:45,300
So you probably want to change my name because,

902
01:33:46,660 --> 01:33:49,100
so the reason is we will actually be uploading this

903
01:33:49,100 --> 01:33:51,020
to the Python package index,

904
01:33:51,020 --> 01:33:53,260
which means you can install it with pip.

905
01:33:53,260 --> 01:33:58,260
And that means, yeah, so you don't want,

906
01:33:58,420 --> 01:33:59,900
you want a unique name.

907
01:33:59,900 --> 01:34:02,820
If you have, if you try with a name that already exists

908
01:34:02,820 --> 01:34:05,900
in PyPi, that's already a Python package,

909
01:34:05,900 --> 01:34:08,140
then it will not work.

910
01:34:08,140 --> 01:34:13,260
So let's just identify it as the package for Python SciComm 2023.

911
01:34:13,260 --> 01:34:13,980
That's a good idea.

912
01:34:14,940 --> 01:34:17,340
Okay, otherwise everything is okay.

913
01:34:17,340 --> 01:34:18,540
It depends on SciPy.

914
01:34:19,980 --> 01:34:25,180
There's a quick example, a quick description and readme file.

915
01:34:28,460 --> 01:34:33,100
Yeah, so you can also add your name and email if you want to.

916
01:34:34,540 --> 01:34:36,140
We could add additional ones.

917
01:34:36,140 --> 01:34:43,480
Yeah, you can add multiple authors. You can add more dependencies. That's all. And, yeah,

918
01:34:43,480 --> 01:34:44,840
there is something called a long description.

919
01:34:44,840 --> 01:34:46,840
I'll leave that at example.org.

920
01:34:46,840 --> 01:34:54,560
Okay. Yeah. So, this is it. And what this does, it makes your package installable with

921
01:34:54,560 --> 01:35:01,480
pip. So, now we can run pip install. And, well, it's not yet on PyPI. It's not yet in

922
01:35:01,480 --> 01:35:07,080
index, so we need to point it by pointing to this folder if we want to install. But let's just

923
01:35:07,080 --> 01:35:14,840
demonstrate it quickly. So pip install dot. Dot is the current folder. Okay. You don't have pip.

924
01:35:20,200 --> 01:35:23,560
Oh, okay. Okay, we will fix this. But that should have worked.

925
01:35:23,560 --> 01:35:29,160
And if you are in the Anaconda environment, base environment, I think this should work.

926
01:35:31,480 --> 01:35:38,840
I would just pip.

927
01:35:38,840 --> 01:35:46,420
So the next thing we do is we go to the exercise which is essentially creating the package

928
01:35:46,420 --> 01:35:51,300
we just created and testing that you can install it locally.

929
01:35:51,300 --> 01:35:59,420
So we will give you, now we're running a bit late, we'll give you 15 minutes anyway because

930
01:35:59,420 --> 01:36:06,700
This is the important part and that means we'll be back at 11.40.

931
01:36:12,540 --> 01:36:17,900
All right, so, yeah, good luck and see you in 15 minutes. Bye.

932
01:36:29,420 --> 01:36:31,480
you

933
01:36:59,420 --> 01:37:01,480
you

934
01:37:29,420 --> 01:37:31,480
you

935
01:37:59,420 --> 01:38:01,480
you

936
01:38:29,420 --> 01:38:31,480
you

937
01:38:59,420 --> 01:39:01,480
you

938
01:39:29,420 --> 01:39:31,480
you

939
01:39:59,420 --> 01:40:01,480
you

940
01:40:29,420 --> 01:40:31,480
you

941
01:40:59,420 --> 01:41:01,480
you

942
01:41:29,420 --> 01:41:31,480
you

943
01:41:59,420 --> 01:42:01,480
you

944
01:42:29,420 --> 01:42:31,480
you

945
01:42:59,420 --> 01:43:01,480
you

946
01:43:29,420 --> 01:43:31,480
you

947
01:43:59,420 --> 01:44:01,480
you

948
01:44:29,420 --> 01:44:31,480
you

949
01:44:59,420 --> 01:45:01,480
you

950
01:45:29,420 --> 01:45:31,480
you

951
01:45:59,420 --> 01:46:01,480
you

952
01:46:29,420 --> 01:46:31,480
you

953
01:46:59,420 --> 01:47:01,480
you

954
01:47:29,420 --> 01:47:31,480
you

955
01:47:59,420 --> 01:48:01,480
you

956
01:48:29,420 --> 01:48:31,480
you

957
01:48:59,420 --> 01:49:01,480
you

958
01:49:29,420 --> 01:49:31,480
you

959
01:49:59,420 --> 01:50:01,480
you

960
01:50:29,420 --> 01:50:31,480
you

961
01:50:59,420 --> 01:51:22,620
Hello. So, yeah, let's go straight into PyPy. This will not take that long. So, we do this

962
01:51:22,620 --> 01:51:28,220
as a demonstration, but you can also follow along and upload your package to test PyPy

963
01:51:28,220 --> 01:51:32,380
preferably, because unless you have an actual package you're going to want to upload.

964
01:51:34,300 --> 01:51:40,140
So yeah, we will be uploading to testpypy. I guess I should explain what pypy is, right?

965
01:51:42,380 --> 01:51:45,900
So pypy stands for Python Package Index.

966
01:51:48,940 --> 01:51:55,820
And when you type pip install and just the package name instead of a folder, for example,

967
01:51:55,820 --> 01:52:02,940
then it will look for that package in PyPy in the Python package index and yeah you can push

968
01:52:02,940 --> 01:52:08,620
your packages there and then people can install them with just pip install the name. So it's a

969
01:52:08,620 --> 01:52:15,260
very useful thing to have. So yeah we'll show you how to use it and you can follow along if you want

970
01:52:15,260 --> 01:52:23,740
to and you can upload something to test PyPy with these instructions. And yeah test PyPy is

971
01:52:23,740 --> 01:52:29,900
kind of what it says so it's for testing and your packages will get removed rather quickly.

972
01:52:29,900 --> 01:52:36,380
I don't remember how quickly exactly but it's not meant for actual packages. I have the impression

973
01:52:36,380 --> 01:52:43,420
it's not that quickly I just found that there's still one that I probably put on there a year ago.

974
01:52:45,340 --> 01:52:53,260
Okay I'm kind of surprised but okay well fine. Anyway so it is meant for testing

975
01:52:53,260 --> 01:52:59,580
So yeah, so let's just go through the steps on how to get this package into PyPy.

976
01:52:59,580 --> 01:53:01,740
So yeah, first you run build.

977
01:53:03,980 --> 01:53:04,860
This doesn't work.

978
01:53:08,860 --> 01:53:09,340
Okay.

979
01:53:09,340 --> 01:53:14,860
Build is a package and cannot be directly executed, but that's kind of the point, isn't it?

980
01:53:16,380 --> 01:53:16,880
Should be.

981
01:53:17,820 --> 01:53:21,420
Okay, so maybe we need to update the instructions a bit. Let's see.

982
01:53:23,260 --> 01:53:31,900
What about twine.build, maybe?

983
01:53:31,900 --> 01:53:33,340
OK, that could be.

984
01:53:33,340 --> 01:53:37,540
Or, well, OK, let's install twine.

985
01:53:37,540 --> 01:53:39,940
Yeah, OK, that's the next step.

986
01:53:39,940 --> 01:53:48,940
So Python packaging guide tells you to, oh, come on.

987
01:53:48,940 --> 01:53:50,620
And we are using setup tools.

988
01:53:53,260 --> 01:53:54,260
Okay.

989
01:53:54,260 --> 01:53:55,260
Okay.

990
01:53:55,260 --> 01:54:08,260
Well, it tells you to install build using Python, using pip.

991
01:54:08,260 --> 01:54:10,260
Let's try that.

992
01:54:10,260 --> 01:54:18,260
This is a relatively new site, right?

993
01:54:18,260 --> 01:54:21,260
PyPi instructions.

994
01:54:21,260 --> 01:54:28,540
Can you try running pip install, or did you try installing Twine and it didn't work?

995
01:54:28,540 --> 01:54:33,540
I tried installing Twine and it didn't want to do, so I'm going back to the base environment

996
01:54:33,540 --> 01:54:34,540
to see.

997
01:54:34,540 --> 01:54:35,540
Oh, okay.

998
01:54:35,540 --> 01:54:37,740
This, well, we'll try for another two minutes, say, but.

999
01:54:37,740 --> 01:54:39,980
Actually, Twine might just be the uploader.

1000
01:54:39,980 --> 01:54:43,380
No, pip install Twine.

1001
01:54:43,380 --> 01:54:44,380
Okay.

1002
01:54:44,380 --> 01:54:45,380
Okay.

1003
01:54:45,380 --> 01:54:46,380
Okay.

1004
01:54:46,380 --> 01:54:47,380
Okay.

1005
01:54:47,380 --> 01:54:49,960
Okay, and then pip install build.

1006
01:54:55,140 --> 01:54:59,540
Okay, now let's try Python 3 minus m build.

1007
01:55:03,580 --> 01:55:05,140
The tree is in the wrong place.

1008
01:55:07,460 --> 01:55:08,300
Yeah.

1009
01:55:09,740 --> 01:55:12,880
So there has been a relatively recent change in.

1010
01:55:17,380 --> 01:55:19,860
OK, that did something.

1011
01:55:19,860 --> 01:55:21,980
Good?

1012
01:55:21,980 --> 01:55:23,140
Yeah, that looks correct.

1013
01:55:27,140 --> 01:55:29,780
OK.

1014
01:55:29,780 --> 01:55:35,020
And then we'll try Twine upload.

1015
01:55:35,020 --> 01:55:37,820
So Twine is a Python package that

1016
01:55:37,820 --> 01:55:44,140
uploads things into the Python package index.

1017
01:55:44,140 --> 01:55:49,740
here we are specifying to put it into the test index. You do need a username and a password,

1018
01:55:49,740 --> 01:55:55,020
you need to create an account to upload anything and it will of course be associated with your

1019
01:55:55,020 --> 01:56:13,900
account. Okay there we are and now we can try installing it. So normally if you put

1020
01:56:13,900 --> 01:56:18,220
something into PyPy, it's just pip install package name, but in this case we need to

1021
01:56:18,220 --> 01:56:29,100
tell it to use the test PyPy instead. What was the name? It was underscore after four, I think.

1022
01:56:35,260 --> 01:56:38,460
I tried like this because it seems like it changed the underscores.

1023
01:56:38,460 --> 01:56:41,260
Oh, okay. All right, so yeah.

1024
01:56:41,260 --> 01:56:48,460
underscore is not allowed now it's installing our package yeah and now we should have it

1025
01:56:55,260 --> 01:57:02,220
so is it now called calculator for pi sc 2023 or is it just called calculator we will see

1026
01:57:06,460 --> 01:57:10,620
oh well they are definitely not with minus signs it changes minus signs to underscores

1027
01:57:11,260 --> 01:57:22,260
Okay, well, we did run into a couple of problems here, but okay, fine.

1028
01:57:22,260 --> 01:57:29,740
So we need to update this example a little bit to use SciPy correctly and to, well, I

1029
01:57:29,740 --> 01:57:36,700
guess the instructions for uploading the PyPy were correct, but somehow it didn't work in

1030
01:57:36,700 --> 01:57:39,140
that one environment.

1031
01:57:39,140 --> 01:57:44,260
So something called build was already installed,

1032
01:57:44,260 --> 01:57:45,620
but it wasn't.

1033
01:57:45,620 --> 01:57:47,460
Oh, no, no, maybe it just wasn't installed

1034
01:57:47,460 --> 01:57:48,900
and it was just a folder.

1035
01:57:51,420 --> 01:57:53,860
In any case, it worked.

1036
01:57:53,860 --> 01:57:57,220
I have an impression that the SciPy version that

1037
01:57:57,220 --> 01:58:04,740
is being used here is not really what we want.

1038
01:58:04,740 --> 01:58:05,500
Could be.

1039
01:58:05,500 --> 01:58:07,860
Yeah, the SciPy 0.1.

1040
01:58:07,860 --> 01:58:14,500
0.1 is not what we want. Why would it – oh, because it's from test.py. It got SciPy from

1041
01:58:14,500 --> 01:58:21,060
test.py. So, it didn't get the latest version. It got whatever they used for testing a long time

1042
01:58:21,060 --> 01:58:32,100
ago when they tested uploading SciPy last time. All right. In any case, that is how you upload

1043
01:58:32,100 --> 01:58:40,180
packages to scipy and also to pypy to the python package index and that makes installing them a lot

1044
01:58:40,180 --> 01:58:48,980
more straightforward for your friends and collaborators. All right so there's one thing

1045
01:58:48,980 --> 01:58:53,380
I quickly want to point out this question about what the license and readme files should say.

1046
01:58:54,100 --> 01:59:00,340
So in the exercise description we added a lot of details about well essentially we just added

1047
01:59:00,340 --> 01:59:08,500
links to Code Refinery materials which you can read up on your own time or come to the

1048
01:59:08,500 --> 01:59:18,060
Code Refinery course. We would love to have you there. There's something about documentation

1049
01:59:18,060 --> 01:59:27,900
in general, so that also tells you some ways of writing README files. In social coding,

1050
01:59:27,900 --> 01:59:34,620
is a part about software licensing the general instruction the most important thing is use an

1051
01:59:34,620 --> 01:59:41,500
existing license don't write your own because it's legal language and yeah it's better to leave

1052
01:59:41,500 --> 01:59:50,140
that for the lawyers and then there's a section on testing automated testing which we mentioned

1053
01:59:50,140 --> 01:59:54,380
it's nice thing to have in a package but we didn't actually show you how to do it so there

1054
01:59:54,380 --> 02:00:01,580
is a section on that. Otherwise we are right on time for a break. Anything else?

1055
02:00:03,580 --> 02:00:12,700
I think not really. All right, so let's take a 10-minute break and then come back for web APIs.

1056
02:00:16,060 --> 02:00:18,780
All right, bye.

1057
02:00:24,380 --> 02:00:26,440
you

1058
02:00:54,380 --> 02:00:56,440
you

1059
02:01:24,380 --> 02:01:26,440
you

1060
02:01:54,380 --> 02:01:56,440
you

1061
02:02:24,380 --> 02:02:26,440
you

1062
02:02:54,380 --> 02:02:56,440
you

1063
02:03:24,380 --> 02:03:26,440
you

1064
02:03:54,380 --> 02:03:56,440
you

1065
02:04:24,380 --> 02:04:26,440
you

1066
02:04:54,380 --> 02:04:56,440
you

1067
02:05:24,380 --> 02:05:26,440
you

1068
02:05:54,380 --> 02:05:56,440
you

1069
02:06:24,380 --> 02:06:26,440
you

1070
02:06:54,380 --> 02:06:56,440
you

1071
02:07:24,380 --> 02:07:26,440
you

1072
02:07:54,380 --> 02:07:56,440
you

1073
02:08:24,380 --> 02:08:26,440
you

1074
02:08:54,380 --> 02:08:56,440
you

1075
02:09:24,380 --> 02:09:26,440
you

1076
02:09:54,380 --> 02:09:56,440
you

1077
02:10:24,380 --> 02:10:53,540
Thank you very much.

1078
02:10:53,540 --> 02:10:56,540
We are back.

1079
02:10:56,540 --> 02:11:04,500
So the last real lesson of the day is now web APIs.

1080
02:11:04,500 --> 02:11:06,860
So Enrico, how do we start?

1081
02:11:06,860 --> 02:11:12,100
Yes, so maybe it's good to start with understanding

1082
02:11:12,100 --> 02:11:14,540
what do we mean with web API.

1083
02:11:14,540 --> 02:11:18,660
And I don't know if everybody knows what API means,

1084
02:11:18,660 --> 02:11:22,940
but most likely everybody knows what UI means, user interface.

1085
02:11:22,940 --> 02:11:28,540
So for example, most, let's say they want to search something with the browser, with

1086
02:11:28,540 --> 02:11:33,460
the window, which is your user interface, you go to a website like google.com and that's

1087
02:11:33,460 --> 02:11:35,180
the interface that you work with.

1088
02:11:35,180 --> 02:11:39,420
You type something and you get an answer, the search results.

1089
02:11:39,420 --> 02:11:44,360
So API, the interface now is application program interface.

1090
02:11:44,360 --> 02:11:49,400
So it's like that the interface is not designed anymore for humans who can, you know, use the

1091
02:11:49,400 --> 02:11:52,600
mouse and type and do things like that.

1092
02:11:52,600 --> 02:11:55,680
that we can basically use machines.

1093
02:11:55,680 --> 02:11:59,480
So basically this kind of goes down

1094
02:11:59,480 --> 02:12:02,440
to the concept of server.

1095
02:12:02,440 --> 02:12:05,360
I don't think we need to go into the details

1096
02:12:05,360 --> 02:12:07,520
what is a server, but in general,

1097
02:12:07,520 --> 02:12:11,160
we are all using these servers,

1098
02:12:11,160 --> 02:12:15,760
meaning these softwares that when we ask for a page

1099
02:12:15,760 --> 02:12:17,720
or when we ask for some information,

1100
02:12:17,720 --> 02:12:21,360
whether it's with our smartphones or with our computers,

1101
02:12:21,360 --> 02:12:26,360
we get an answer, so we are served with an answer.

1102
02:12:28,640 --> 02:12:32,280
So what we are gonna cover here is that sometimes

1103
02:12:32,280 --> 02:12:35,840
in some cases, it's very useful to interact

1104
02:12:35,840 --> 02:12:39,160
with these sources of data that are not physically stored

1105
02:12:39,160 --> 02:12:41,080
on the same machine where you are.

1106
02:12:41,080 --> 02:12:43,880
Like the example that I gave that you might wanna query

1107
02:12:43,880 --> 02:12:46,760
something from Google, but instead of looking

1108
02:12:46,760 --> 02:12:50,400
at the answer yourself, you can have Python

1109
02:12:50,400 --> 02:12:57,440
look at the at the answer. And then of course there are other more advanced uses of the so-called

1110
02:12:57,440 --> 02:13:03,680
APIs, meaning that there are companies who might give you access to a specific API to do something.

1111
02:13:04,400 --> 02:13:09,520
I guess you all have heard about OpenAI and ChatGPT. That's another example that, you know,

1112
02:13:09,520 --> 02:13:17,120
it would have been possible to store this huge GPT model on your local machine so you can,

1113
02:13:17,120 --> 02:13:24,720
for example via Python, send the query or like the prompt that you would send to the remote

1114
02:13:24,720 --> 02:13:30,960
computer and then get an answer back. The most simple way of doing this programmatically with

1115
02:13:30,960 --> 02:13:38,320
Python is with this package called requests. So request is a Python library that makes

1116
02:13:38,320 --> 02:13:44,800
requests to web servers as I just gave you some example. You see here in the bottom there is this

1117
02:13:44,800 --> 02:13:53,080
Basically, the web page for this request is embedded there, and they label it as HTTP

1118
02:13:53,080 --> 02:13:54,080
for humans.

1119
02:13:54,080 --> 02:14:00,080
Maybe I could ask Richard, what does HTTP mean, even though we type it almost every

1120
02:14:00,080 --> 02:14:01,080
day?

1121
02:14:01,080 --> 02:14:02,080
Yeah.

1122
02:14:02,080 --> 02:14:11,680
So, HTTP means Hypertext Transfer Protocol, and it's basically the way everything communicates

1123
02:14:11,680 --> 02:14:13,440
with the web server.

1124
02:14:13,440 --> 02:14:18,480
you send the request saying, I would like to see this web page,

1125
02:14:18,480 --> 02:14:23,080
and it sends back saying, OK, here's the data you requested.

1126
02:14:23,080 --> 02:14:24,960
And you can give other parameters,

1127
02:14:24,960 --> 02:14:29,920
like what languages my web browser is configured to show,

1128
02:14:29,920 --> 02:14:34,360
or things like that.

1129
02:14:34,360 --> 02:14:37,440
And for humans, means that request

1130
02:14:37,440 --> 02:14:43,440
is trying to make it a way that's well that's

1131
02:14:43,440 --> 02:14:46,080
easily easy to use by humans so they really

1132
02:14:46,080 --> 02:14:48,720
care about the user interface of this.

1133
02:14:48,720 --> 02:14:52,920
Exactly, which basically simplifies your work.

1134
02:14:52,920 --> 02:14:55,200
As usual, maybe one of the biggest lesson

1135
02:14:55,200 --> 02:14:58,120
here in this course is that often there's

1136
02:14:58,120 --> 02:15:00,120
no need to reinvent any wheels.

1137
02:15:00,120 --> 02:15:01,800
There are already very good packages

1138
02:15:01,800 --> 02:15:04,640
that can do the heavy lifting for you.

1139
02:15:04,640 --> 02:15:08,460
So here in this retrieve data from API,

1140
02:15:08,460 --> 02:15:12,300
the introduction text there is basically telling you

1141
02:15:12,300 --> 02:15:14,700
that there is a list of many

1142
02:15:14,700 --> 02:15:17,180
of these application program interfaces

1143
02:15:17,180 --> 02:15:19,540
that can be used without a key.

1144
02:15:19,540 --> 02:15:21,580
So this is something that if you will start working

1145
02:15:21,580 --> 02:15:25,460
with external API, sometimes you need to have a key.

1146
02:15:25,460 --> 02:15:28,420
For example, in the OpenAI chat GPT example

1147
02:15:28,420 --> 02:15:29,620
that I was giving you earlier,

1148
02:15:29,620 --> 02:15:33,060
if you want to query the remote model,

1149
02:15:33,060 --> 02:15:37,900
you need to basically show that it's you through a key,

1150
02:15:37,900 --> 02:15:39,180
through a token.

1151
02:15:39,180 --> 02:15:42,780
But in this case, we're gonna use an API called cat fact,

1152
02:15:42,780 --> 02:15:45,620
which is basically it's going to return

1153
02:15:45,620 --> 02:15:49,140
some random fact about cats.

1154
02:15:49,140 --> 02:15:52,340
And so maybe, you know, enough with the talking,

1155
02:15:52,340 --> 02:15:56,340
should we just get started with some Python?

1156
02:15:58,700 --> 02:15:59,860
Sure.

1157
02:15:59,860 --> 02:16:02,580
Okay, I'm arranging things.

1158
02:16:02,580 --> 02:16:03,080
Yep.

1159
02:16:03,080 --> 02:16:06,900
So I guess I will make a new notebook in my place

1160
02:16:06,900 --> 02:16:14,740
and rename it to, OK.

1161
02:16:14,740 --> 02:16:16,060
So how should I start?

1162
02:16:16,060 --> 02:16:17,740
Yeah, so if you scroll a bit down,

1163
02:16:17,740 --> 02:16:21,020
and you can also do the same for those who are watching,

1164
02:16:21,020 --> 02:16:23,660
there's a section a little bit more down in the materials

1165
02:16:23,660 --> 02:16:29,620
where we basically start with the import for this library.

1166
02:16:32,580 --> 02:16:37,220
And then the code will also have this URL.

1167
02:16:37,220 --> 02:16:40,740
So URL, it means Uniform Resource Locator.

1168
02:16:40,740 --> 02:16:44,580
It's basically, again, what we normally type daily.

1169
02:16:44,580 --> 02:16:46,920
It's the address of this,

1170
02:16:46,920 --> 02:16:49,800
in this case of this remote server API.

1171
02:16:51,940 --> 02:16:53,380
And then we can use this library,

1172
02:16:53,380 --> 02:16:58,380
this request library by getting this URL.

1173
02:16:59,940 --> 02:17:02,020
So what happens?

1174
02:17:02,580 --> 02:17:08,060
So now there should be something inside this response.

1175
02:17:08,060 --> 02:17:10,940
So it's a response object.

1176
02:17:14,580 --> 02:17:20,220
So with objects, you know that with dot and name of the name

1177
02:17:20,220 --> 02:17:22,940
of the field, you can actually get some content.

1178
02:17:22,940 --> 02:17:27,020
And here we see basically a string that starts with the B

1179
02:17:27,020 --> 02:17:29,580
and lots of stuff.

1180
02:17:29,580 --> 02:17:34,580
So, the string looks like JSON, but it has a B in front.

1181
02:17:34,580 --> 02:17:37,580
What does the B stand for, Richard?

1182
02:17:37,580 --> 02:17:41,580
That's a thing I like talking about.

1183
02:17:41,580 --> 02:17:48,580
So, it looks like a string, but the B in front means Python is interpreting this as binary data.

1184
02:17:48,580 --> 02:17:53,580
So basically, it's not assuming it has a text encoding.

1185
02:17:53,580 --> 02:18:01,420
In Python, all the things that look like strings are either unicode strings, meaning they should

1186
02:18:01,420 --> 02:18:08,580
contain text and can have any unicode character, like each index is a character, or B, which

1187
02:18:08,580 --> 02:18:19,820
means each position in the string is raw, like a raw byte from 0 to 255.

1188
02:18:19,820 --> 02:18:22,340
But I think we probably shouldn't go too much into that.

1189
02:18:22,340 --> 02:18:26,260
It's something you can get deep into later.

1190
02:18:26,260 --> 02:18:30,140
But then the rest of the whatever comes after the B

1191
02:18:30,140 --> 02:18:31,340
looks like JSON.

1192
02:18:31,340 --> 02:18:33,740
Did we introduce before what do we

1193
02:18:33,740 --> 02:18:37,380
mean with JSON, the JSON format?

1194
02:18:37,380 --> 02:18:37,940
I don't know.

1195
02:18:37,940 --> 02:18:38,460
Did we?

1196
02:18:38,460 --> 02:18:42,460
Maybe I should say again anyway.

1197
02:18:42,460 --> 02:18:43,580
Yeah.

1198
02:18:43,580 --> 02:18:49,940
So JSON is a way to turn objects into strings.

1199
02:18:49,940 --> 02:18:54,780
So this looks like it would be a Python dictionary,

1200
02:18:54,780 --> 02:18:57,460
but actually, it's all encoded in a string.

1201
02:18:57,460 --> 02:19:00,260
And basically, JSON is a way to do

1202
02:19:00,260 --> 02:19:04,100
that encoding in a way that's standardized and shareable

1203
02:19:04,100 --> 02:19:07,500
among different computers.

1204
02:19:07,500 --> 02:19:12,800
And many, many APIs that basically will return strings,

1205
02:19:12,800 --> 02:19:15,820
they will actually give you the answer in JSON.

1206
02:19:15,820 --> 02:19:21,100
And this is why this response library also has a dot JSON function.

1207
02:19:21,100 --> 02:19:30,800
So what if we tried the, um, exactly that part of the, so now basically is

1208
02:19:30,800 --> 02:19:38,960
this like, like, um, dictionary basically, let's see, yes, it is a dictionary.

1209
02:19:40,320 --> 02:19:45,200
So then we could know easily access, for example, using the keys, the

1210
02:19:45,200 --> 02:19:53,360
different elements yeah all right instead this this what you did earlier now it's listed

1211
02:19:53,360 --> 02:19:57,600
as bytes because it's it has to be the yeah

1212
02:19:57,600 --> 02:20:10,800
so now basically you are you're yeah you're putting the this dictionary into a variable

1213
02:20:10,800 --> 02:20:18,480
corresponds underscore json and then you're getting the key fact yeah all right so so far so good we

1214
02:20:18,480 --> 02:20:25,200
saw basically that we can basically get some data and get is one of these terms using this

1215
02:20:25,200 --> 02:20:33,360
http protocol but sometimes we also want to maybe send or at least tell the remote server that you

1216
02:20:33,360 --> 02:20:38,560
know maybe we don't want to just get the page like in this specific case but we want to filter

1217
02:20:38,560 --> 02:20:43,560
according to what the remote API is allowing us.

1218
02:20:43,560 --> 02:20:48,160
So often you might, again, have seen this

1219
02:20:48,160 --> 02:20:49,880
when you browse the internet,

1220
02:20:49,880 --> 02:20:53,860
you might see a URL and then a question mark

1221
02:20:53,860 --> 02:20:58,860
followed by various values or like key equal values.

1222
02:20:59,960 --> 02:21:01,320
So these are basically,

1223
02:21:01,320 --> 02:21:05,300
these are called parameters for the GET query.

1224
02:21:05,300 --> 02:21:08,820
And in this specific case, for example,

1225
02:21:08,820 --> 02:21:12,220
we use a remote API that is called

1226
02:21:12,220 --> 02:21:15,580
universities.hypolabs.com, which is basically

1227
02:21:15,580 --> 02:21:19,420
providing a list of all the universities in the planet.

1228
02:21:19,420 --> 02:21:21,740
But you see here that now this URL

1229
02:21:21,740 --> 02:21:26,180
has a parameter as a question mark, country equal Finland.

1230
02:21:26,180 --> 02:21:35,100
So if we run this code and we get the request from this URL,

1231
02:21:35,100 --> 02:21:39,340
Will it most likely give us basically a list

1232
02:21:39,340 --> 02:21:41,940
of the universities in Finland?

1233
02:21:41,940 --> 02:21:46,540
And as you can see already, indeed, it does.

1234
02:21:46,540 --> 02:21:49,500
In this case, why did you put like,

1235
02:21:49,500 --> 02:21:53,380
can we remind people what is this column 2?

1236
02:21:53,380 --> 02:21:57,620
And this says it's giving the first two elements

1237
02:21:57,620 --> 02:22:00,420
of the array.

1238
02:22:00,420 --> 02:22:04,340
So if I remove it, then it will be a log response.

1239
02:22:04,340 --> 02:22:10,100
Exactly. And we will see all the list. But then this is the thing. So now we were passing this

1240
02:22:10,100 --> 02:22:18,580
parameter through this question mark, followed by key, name of the parameter and the value.

1241
02:22:19,300 --> 02:22:22,100
But this library, the response library is actually,

1242
02:22:24,820 --> 02:22:29,540
with the response library is also possible to pass the parameters via the Python request.

1243
02:22:29,540 --> 02:22:37,380
So, should we try this bit of code, Richa, where now, instead of, so the URL now is different,

1244
02:22:37,380 --> 02:22:42,960
it's just a general URL for the API.

1245
02:22:42,960 --> 02:22:48,260
But now we pass the parameter country equal to Finland, basically.

1246
02:22:48,260 --> 02:22:50,580
So I've just copied the whole thing.

1247
02:22:50,580 --> 02:22:51,580
Yeah.

1248
02:22:51,580 --> 02:22:58,060
I guess the key point here is this parameters equals parameters, which is a dictionary.

1249
02:22:58,060 --> 02:22:59,380
Exactly.

1250
02:22:59,380 --> 02:23:04,340
And now it will give the same results, but you can try, for example, with your own country,

1251
02:23:04,340 --> 02:23:09,660
you can put Sweden, you can put Norway, and then you can get programmatically, you can

1252
02:23:09,660 --> 02:23:18,260
get the list of all the universities that are at least listed in this remote API.

1253
02:23:18,260 --> 02:23:25,980
So this is basically the main idea behind this remote APIs.

1254
02:23:25,980 --> 02:23:33,500
rather than talking we could let people try exercise one it's an exercise where in this

1255
02:23:33,500 --> 02:23:39,500
case you don't have to how can I say think the solution the solution is actually following

1256
02:23:39,500 --> 02:23:47,060
after the exercise so it's an opportunity for you to test another API so even copy pasting

1257
02:23:47,060 --> 02:23:53,980
is fine and exploring the output and when it gives we could assign 10 minutes if these

1258
02:23:53,980 --> 02:24:00,060
are too short for exercise 1 you can also start with exercise 2 and then later we will

1259
02:24:00,060 --> 02:24:08,540
comment on what is going on with exercise 2. Does this sound like a good plan, Richard?

1260
02:24:08,540 --> 02:24:12,380
Yes, it is. Yes, very good.

1261
02:24:12,380 --> 02:24:20,620
So let's have until 12.23 start with exercise 1 and if you have time do exercise 2 and then

1262
02:24:20,620 --> 02:24:26,140
we will come back and do a recap and more stuff.

1263
02:24:26,140 --> 02:24:28,540
OK, sounds good.

1264
02:24:28,540 --> 02:24:31,020
See you later.

1265
02:24:31,020 --> 02:24:32,580
Bye.

1266
02:24:50,620 --> 02:24:52,680
you

1267
02:25:20,620 --> 02:25:22,680
you

1268
02:25:50,620 --> 02:25:52,680
you

1269
02:26:20,620 --> 02:26:22,680
you

1270
02:26:50,620 --> 02:26:52,680
you

1271
02:27:20,620 --> 02:27:22,680
you

1272
02:27:50,620 --> 02:27:52,680
you

1273
02:28:20,620 --> 02:28:22,680
you

1274
02:28:50,620 --> 02:28:52,680
you

1275
02:29:20,620 --> 02:29:22,680
you

1276
02:29:50,620 --> 02:29:52,680
you

1277
02:30:20,620 --> 02:30:22,680
you

1278
02:30:50,620 --> 02:30:52,680
you

1279
02:31:20,620 --> 02:31:22,680
you

1280
02:31:50,620 --> 02:31:52,680
you

1281
02:32:20,620 --> 02:32:22,680
you

1282
02:32:50,620 --> 02:32:52,680
you

1283
02:33:20,620 --> 02:33:46,780
There was a nice interesting question in our notes document, are there any best practices

1284
02:33:46,780 --> 02:33:52,380
or general guidelines, but when it comes to the coding, the examples that we gave you

1285
02:33:52,380 --> 02:34:00,100
with this request library, it's a good starting point for working with web APIs.

1286
02:34:00,100 --> 02:34:04,900
But then one should also consider maybe the ethical and sometimes even the legal aspect.

1287
02:34:04,900 --> 02:34:13,260
Ethical, it can be in the sense that, you know, are you allowed to use this data?

1288
02:34:13,260 --> 02:34:15,540
Is it ethical to scrape this data?

1289
02:34:15,540 --> 02:34:25,620
we do this for research purposes, so we can do these things, we don't break any law.

1290
02:34:25,620 --> 02:34:31,140
But then there's also the ethics of the fact that you are sending many queries to some

1291
02:34:31,140 --> 02:34:36,100
remote computer that maybe you don't want to overload the remote server, I don't know,

1292
02:34:36,100 --> 02:34:44,900
with 1,000 queries every second. So then often if you, let's say that you need to scrape

1293
02:34:44,900 --> 02:34:51,580
many many web pages and we will soon show briefly a little example on that maybe you

1294
02:34:51,580 --> 02:34:55,900
don't wanna you know maybe you wanna have a break between every every page so that your

1295
02:34:55,900 --> 02:35:03,380
Python code could scrape one page wait for a few minutes scrape another page and so on.

1296
02:35:03,380 --> 02:35:11,160
So there's no comments related to the exercises so most likely they were easy and understandable

1297
02:35:11,160 --> 02:35:18,920
Maybe regarding exercise two, Richard, exercise two talks about something that we didn't really

1298
02:35:18,920 --> 02:35:26,720
cover before, the headers. In practice, if I understand it correctly, it's like what

1299
02:35:26,720 --> 02:35:31,920
we tell to the remote server, like I'm on this computer with this operating system and

1300
02:35:31,920 --> 02:35:40,440
this browser, but do we need to sometimes change these headers?

1301
02:35:40,440 --> 02:35:47,720
I've done it occasionally. So sometimes the headers can be used for, for example, passing

1302
02:35:47,720 --> 02:35:54,760
authentication information. So the API knows who you are and that you have permission to access it,

1303
02:35:55,640 --> 02:35:59,640
but oftentimes there's other things in requests that can handle this for you.

1304
02:36:00,520 --> 02:36:07,640
Sometimes the headers would say things like what format you want the data in, or things like that.

1305
02:36:07,640 --> 02:36:14,640
And I can't remember an exact time, but I've probably done it once or twice.

1306
02:36:14,640 --> 02:36:22,800
Exactly. In the learning materials, there is an example where there are some example

1307
02:36:22,800 --> 02:36:30,760
of these headers that according to what you need to pass to the server, you need to modify

1308
02:36:30,760 --> 02:36:37,440
eventually. But often, if your goal is, for example, to scrape materials from the internet,

1309
02:36:37,440 --> 02:36:45,720
it's okay to use the default headers of the request API, of the request library.

1310
02:36:45,720 --> 02:36:51,160
And when it comes to scraping exercise three, we don't have time to go through it. So please

1311
02:36:51,160 --> 02:36:59,960
go, please do it if you have time. So the code that we see here is basically an example

1312
02:36:59,960 --> 02:37:04,960
where we wanna download the full HTML of a remote server.

1313
02:37:05,480 --> 02:37:08,560
So now it does not an API in the sense

1314
02:37:08,560 --> 02:37:13,320
that there's some software that even the parameters

1315
02:37:13,320 --> 02:37:15,680
that we pass is going to return an answer

1316
02:37:15,680 --> 02:37:17,840
like we had earlier JSON.

1317
02:37:17,840 --> 02:37:20,360
But now what is returned is basically

1318
02:37:20,360 --> 02:37:24,080
the so-called HTML code, which is this structure

1319
02:37:24,080 --> 02:37:28,000
which is the language of the web pages that you see.

1320
02:37:28,000 --> 02:37:31,360
So, in practice, with the example that you see here,

1321
02:37:31,360 --> 02:37:35,320
you request the HTML of some page,

1322
02:37:35,320 --> 02:37:37,620
in this case, example.com,

1323
02:37:37,620 --> 02:37:39,920
and then there's another library that is used.

1324
02:37:41,040 --> 02:37:44,720
If you scroll a little bit more down after this HTML,

1325
02:37:44,720 --> 02:37:46,360
there is this beautiful soup,

1326
02:37:46,360 --> 02:37:49,120
which is one package that allows you

1327
02:37:49,120 --> 02:37:53,760
to basically parse the HTML so that, again,

1328
02:37:53,760 --> 02:37:56,300
you don't need to invent new wheels

1329
02:37:56,300 --> 02:38:02,840
to extract the information that you need here basically it creates a structure of all the

1330
02:38:02,840 --> 02:38:09,200
tags that are contained in this HTML file and for example one can look at the title

1331
02:38:09,200 --> 02:38:17,720
of the page or look for all the links the links are marked with this tag A and so this

1332
02:38:17,720 --> 02:38:24,040
is why there you see find all A there so that will search for all the links in this case

1333
02:38:24,040 --> 02:38:31,560
there was just one link in this web page but it's time to wrap up maybe there's also something

1334
02:38:31,560 --> 02:38:39,000
else interesting in this web page which is saving the data the example there it's a useful

1335
02:38:39,000 --> 02:38:46,000
example there's nothing too difficult there but it's a nice example of doing multiple

1336
02:38:46,000 --> 02:38:53,040
queries one after the other like I mentioned earlier and and you see at the very last line

1337
02:38:53,040 --> 02:38:55,120
there is this sleep.

1338
02:38:55,120 --> 02:38:56,920
If you scroll up a bit, yeah.

1339
02:38:56,920 --> 02:38:58,280
So this is exactly the thing.

1340
02:38:58,280 --> 02:39:01,560
So we put one second between the multiple queries.

1341
02:39:01,560 --> 02:39:06,080
In this case, there are three queries to this cat fact API.

1342
02:39:06,920 --> 02:39:07,840
And then what's happening,

1343
02:39:07,840 --> 02:39:11,680
this code that this JSON replies from the APIs,

1344
02:39:11,680 --> 02:39:16,280
they're stored, they're appended to the same text file.

1345
02:39:16,280 --> 02:39:18,880
And this is a useful way to deal with kind of

1346
02:39:18,880 --> 02:39:20,640
to basically building a data set.

1347
02:39:20,640 --> 02:39:27,040
So at the end, you will have a big JSON file

1348
02:39:27,040 --> 02:39:30,040
that everywhere, every line is a JSON string.

1349
02:39:30,040 --> 02:39:33,080
And then most likely from this type of data,

1350
02:39:33,080 --> 02:39:35,160
from this format, maybe you want to move it

1351
02:39:35,160 --> 02:39:39,400
into a pandas data frame to basically continue

1352
02:39:39,400 --> 02:39:42,240
your analysis.

1353
02:39:42,240 --> 02:39:43,120
I think we are done.

1354
02:39:43,120 --> 02:39:48,280
Richard, do you have any comments on this data storage

1355
02:39:48,280 --> 02:39:49,120
from API?

1356
02:39:49,120 --> 02:39:58,320
Yes, I would say so how this data storage relates to what we talked about yesterday or two days ago.

1357
02:39:59,520 --> 02:40:06,320
So you might have different ways of storing data for different purposes.

1358
02:40:06,320 --> 02:40:12,320
So for example when it's downloading you want a file format where you can easily append

1359
02:40:12,320 --> 02:40:19,760
expedited to, and it won't get broken, like it can't really get corrupted. So for that,

1360
02:40:19,760 --> 02:40:28,080
downloading and storing in a giant text file with one line per thing, that's easy and relatively

1361
02:40:28,080 --> 02:40:32,400
foolproof. But when you're analyzing, then you might convert this to some other format,

1362
02:40:32,400 --> 02:40:39,760
which is more efficient for your other analysis. There's a comment there, like,

1363
02:40:39,760 --> 02:40:45,520
what a good way to be to store it in an SQL server of some sort. I mean, it could be done

1364
02:40:46,960 --> 02:40:56,000
if you have that set up. Many of our researchers have access to a big file system, but not an SQL

1365
02:40:56,000 --> 02:41:05,840
server. But another thing like saving it to disk first, just so you have it, because the file

1366
02:41:05,840 --> 02:41:14,080
system is more reliable than SQL server for, well, not getting corrupted.

1367
02:41:14,080 --> 02:41:15,080
Yeah.

1368
02:41:15,080 --> 02:41:16,080
Yeah.

1369
02:41:16,080 --> 02:41:21,920
I guess SQL would be a useful solution if these files, you know, if one is planning

1370
02:41:21,920 --> 02:41:29,680
to store 1 million JSON files, maybe that's not the best, but, you know.

1371
02:41:29,680 --> 02:41:30,680
Yeah.

1372
02:41:30,680 --> 02:41:31,680
Yeah.

1373
02:41:31,680 --> 02:41:34,240
I mean, it really depends on the site.

1374
02:41:34,240 --> 02:41:39,360
So even if you're scraping whole internet-level things,

1375
02:41:39,360 --> 02:41:42,080
you have to really think about this

1376
02:41:42,080 --> 02:41:45,880
and try to do it really well.

1377
02:41:45,880 --> 02:41:49,640
And that's not easy.

1378
02:41:53,440 --> 02:41:56,920
OK, with that being said, I guess

1379
02:41:56,920 --> 02:41:59,200
next is our panel discussion.

1380
02:41:59,200 --> 02:42:06,200
I'll switch to the notes here.

1381
02:42:06,200 --> 02:42:07,200
Yes.

1382
02:42:07,200 --> 02:42:17,200
Unfortunately, not all instructors from the first two days were available, but at least

1383
02:42:17,200 --> 02:42:21,200
we have some Alto people here.

1384
02:42:21,200 --> 02:42:22,200
Yeah.

1385
02:42:22,200 --> 02:42:30,840
So it's basically like our team here is answering questions.

1386
02:42:30,840 --> 02:42:31,340
OK.

1387
02:42:31,340 --> 02:42:35,880
So yeah, this is something that we tried a year or two ago

1388
02:42:35,880 --> 02:42:37,520
and worked really well.

1389
02:42:37,520 --> 02:42:50,800
So basically, yeah, think of what you'd like to discuss

1390
02:42:50,800 --> 02:42:53,400
and send it.

1391
02:43:03,800 --> 02:43:05,200
Someone's typing at Jupyter.

1392
02:43:06,000 --> 02:43:06,600
Question.

1393
02:43:09,200 --> 02:43:10,500
Do you use Jupyter training?

1394
02:43:12,300 --> 02:43:12,800
AI?

1395
02:43:13,900 --> 02:43:16,400
Machine learning image analysis algorithm.

1396
02:43:16,400 --> 02:43:28,200
I mean, I would start with Jupyter for most, like, for training a relatively simple model,

1397
02:43:28,200 --> 02:43:33,200
I would start with Jupyter, but then at some point when I'm writing the model, I would

1398
02:43:33,200 --> 02:43:40,720
probably take the model definition part, for example, and move it into a Python file, a

1399
02:43:40,720 --> 02:43:41,720
module.

1400
02:43:41,720 --> 02:43:48,440
Yeah, what a problem can happen with Jupyter is that it's, by design, interactive.

1401
02:43:48,440 --> 02:43:53,560
And interactive is all fun and dandy if you're actually watching the screen and actually typing

1402
02:43:53,560 --> 02:43:57,480
commands. And that is, of course, when you're prototyping a model or something like that,

1403
02:43:57,480 --> 02:44:02,040
you're actually doing it. But when we're talking about longer AI training,

1404
02:44:02,760 --> 02:44:11,080
usually interactive doesn't cut it. Like if Facebook is writing a llama or something,

1405
02:44:11,080 --> 02:44:17,400
there's no one guy running Jupyter cells. They have a non-interactive script that they run on

1406
02:44:17,400 --> 02:44:22,440
a compute cluster. For example, for Lama, they were using two compute clusters with huge amounts

1407
02:44:22,440 --> 02:44:32,200
of GPU resources. If you're doing a big AI training, you usually don't run it in an interactive mode.

1408
02:44:32,200 --> 02:44:37,320
You run it non-interactively and then you store the model checkpoints and that sort of stuff.

1409
02:44:37,320 --> 02:44:48,320
and store results maybe in a TensorBoard or 1 DB or something like that to monitor the training progress.

1410
02:44:48,320 --> 02:44:52,320
But of course for prototyping and that sort of thing, running Jupyter is good.

1411
02:44:52,320 --> 02:44:56,320
But then you usually need to have access to a GPU card.

1412
02:44:56,320 --> 02:45:03,320
And especially in compute clusters, the GPUs are usually demanded by these longer term jobs.

1413
02:45:03,320 --> 02:45:08,920
term jobs, these jobs that run for days and interactive usage basically means

1414
02:45:08,920 --> 02:45:11,760
that it's idling, the GPU is idling most of the time.

1415
02:45:12,120 --> 02:45:16,240
So usually what we recommend is that people who are actively doing

1416
02:45:17,040 --> 02:45:22,080
modern development, they get a cheap gaming GPU to prototype on with

1417
02:45:22,080 --> 02:45:23,200
Jupyter or something like that.

1418
02:45:23,240 --> 02:45:26,760
And then they move on to compute cluster to run the actual

1419
02:45:26,760 --> 02:45:30,440
training that takes days or even longer.

1420
02:45:33,320 --> 02:45:42,760
There's one question about benefits or disadvantages of Python versus other scientific or other

1421
02:45:42,760 --> 02:45:44,080
programming languages.

1422
02:45:44,080 --> 02:45:48,000
The example given here is Matlab.

1423
02:45:48,000 --> 02:45:55,320
My personal take would be one big advantage of Python is that it's open source, mostly.

1424
02:45:55,320 --> 02:46:01,480
There might be some packages where it's a bit more difficult that rely on the proprietary

1425
02:46:01,480 --> 02:46:14,200
software. But overall, it being open source is a big benefit. I have the impression, at least,

1426
02:46:14,200 --> 02:46:20,760
that Python is better when it comes to backward compatibility than, for example, Matlab.

1427
02:46:22,440 --> 02:46:28,120
I think Matlab has a good track record on that. But I'd say that Matlab is basically like,

1428
02:46:28,120 --> 02:46:33,160
You get what you buy because it's a commercial product. There are many

1429
02:46:34,840 --> 02:46:45,400
answers and many programs that are designed for doing some coding or calculations or running

1430
02:46:45,400 --> 02:46:50,200
some simulations. For example, MATLAB is very popular with signal processing people,

1431
02:46:50,200 --> 02:46:56,360
electrical people and that sort of stuff because it has good support for that in the toolboxes.

1432
02:46:56,360 --> 02:47:03,080
but it's like if you want to do MATLAB or web scraping that's not like it doesn't have the

1433
02:47:03,080 --> 02:47:09,080
connections that Python have to other things but it's very good at those things that it's

1434
02:47:09,080 --> 02:47:16,840
been designed to do and what the developers provide but it's not like a generalist programming language

1435
02:47:17,480 --> 02:47:24,360
what Python is as well. Well nowadays MATLAB does have a lot of interfaces with other languages

1436
02:47:24,360 --> 02:47:33,160
So, in the end, it's a bit of a style question.

1437
02:47:33,160 --> 02:47:43,360
And one clear thing is that if you use MATLAB, whoever you think might want to use your code

1438
02:47:43,360 --> 02:47:45,440
also has to have MATLAB.

1439
02:47:45,440 --> 02:47:49,240
And that means they have to pay for it.

1440
02:47:49,240 --> 02:48:00,240
So, I would assume at least that Python code is more widely used just because there is no financial barrier to using it.

1441
02:48:07,240 --> 02:48:17,240
I remember once when I was starting in a previous research group, everyone that comes in says, okay, who has the bootleg MATLAB copy.

1442
02:48:17,240 --> 02:48:22,680
But, you know, I never did that because I use Python and it's free already.

1443
02:48:22,680 --> 02:48:31,520
So, you know, even though it is available, the fact that you have to deal with licenses

1444
02:48:31,520 --> 02:48:46,160
and all that makes it harder and your work less reusable.

1445
02:48:46,160 --> 02:48:52,640
the best way to export plots if you need them as vector graphics. I think Matplotlib does support

1446
02:48:52,640 --> 02:49:00,080
vector graphics, right? Yeah, like probably most of the plotting libraries you could find a way

1447
02:49:00,080 --> 02:49:10,880
to export to SVG or PDF or something. So basically, yeah.

1448
02:49:13,920 --> 02:49:18,320
Let's see. Now we're getting lots of questions here.

1449
02:49:20,320 --> 02:49:26,000
Are you planning to run a Python course on AI and ML? I had answered that up above a little bit,

1450
02:49:26,000 --> 02:49:31,680
and my general thought was there's so many courses about AI and machine learning out there that

1451
02:49:33,680 --> 02:49:39,120
that's not our main target. There's a similar question right below about parallel programming

1452
02:49:39,120 --> 02:49:43,600
which we I mean we covered a lot of things really quickly and didn't go very deep in a

1453
02:49:43,600 --> 02:49:50,320
lot of things. There are a lot of courses out there and materials out there and

1454
02:49:50,320 --> 02:49:58,680
And so, yeah, I'm not sure if we can actually get 500 people or even 100 people in a course

1455
02:49:58,680 --> 02:50:06,400
about MPI or parallel programming in general, but you can study it and then, like, talk

1456
02:50:06,400 --> 02:50:12,480
about it with your local IT people, hopefully it will help.

1457
02:50:12,480 --> 02:50:13,480
Yeah.

1458
02:50:13,480 --> 02:50:16,920
In both cases, like, I think there's this kind of, like, in the industry as a whole,

1459
02:50:16,920 --> 02:50:23,720
is kind of a situation where the examples and small courses on how to write an MPI Hello World

1460
02:50:23,720 --> 02:50:35,640
or how to write a Keras or PyTorch machine learning thing that analyzes the MNIST numbers

1461
02:50:35,640 --> 02:50:43,000
or something. There's lots of material on the first part of the thing. Then there's usually

1462
02:50:43,000 --> 02:50:52,760
how do you scale it up? How do you scale MPI up? Or how do you get a big machine learning pipeline

1463
02:50:52,760 --> 02:50:58,280
or deep learning pipeline, training pipeline working? Then it goes super technical, super

1464
02:50:58,280 --> 02:51:06,760
quickly. And then it gets into this kind of a valley where usually you cross that valley only

1465
02:51:06,760 --> 02:51:15,720
by having engineers or somebody, a support person, who actually constructs a huge scaffolding that

1466
02:51:15,720 --> 02:51:22,840
you can cross the valley. And of course, big companies like Google and Facebook and those

1467
02:51:22,840 --> 02:51:28,440
kinds of companies, they have engineers who do that kind of scaffolding. But teaching that

1468
02:51:28,440 --> 02:51:33,560
that scaffolding is very hard, usually.

1469
02:51:33,560 --> 02:51:40,200
The biggest issue is that teaching that in a general way

1470
02:51:40,200 --> 02:51:42,160
is often not possible.

1471
02:51:42,160 --> 02:51:44,960
Because what you need to do depends

1472
02:51:44,960 --> 02:51:49,160
on your particular field or particular problem.

1473
02:51:49,160 --> 02:51:53,360
So we can teach basics of MPI, how MPI works with our ranks,

1474
02:51:53,360 --> 02:51:56,680
what functions are available to you.

1475
02:51:56,680 --> 02:52:05,240
Then we can talk specifically about your problem, your research field or the program you're writing

1476
02:52:05,240 --> 02:52:14,520
and talk about how to apply that framework. We can teach how to do MNIST with PyTorch

1477
02:52:16,680 --> 02:52:21,560
or do image recognition with PyTorch but then you will have a specific case

1478
02:52:21,560 --> 02:52:29,520
and most of what we – those are – we can give you the basics, but then from there it's

1479
02:52:29,520 --> 02:52:34,980
too specific, so it really only applies to you and a small group of people.

1480
02:52:34,980 --> 02:52:42,200
And then we talk with three people in the room and that's fine, but it's not a course.

1481
02:52:42,200 --> 02:52:48,240
It's a garage session, which is a very useful thing to have.

1482
02:52:48,240 --> 02:52:57,180
Yeah, many of these things which we're talking about, or these other courses requested, they

1483
02:52:57,180 --> 02:53:01,240
already exist, or you can find a good tutorial online.

1484
02:53:01,240 --> 02:53:10,580
And we very carefully targeted this course to things that are important for a junior

1485
02:53:10,580 --> 02:53:17,140
scientist but are not really taught other places.

1486
02:53:17,140 --> 02:53:21,940
you might not know about because of course you have to go follow up for most of these things.

1487
02:53:23,220 --> 02:53:26,020
Can we talk about a little bit about what our daily jobs are?

1488
02:53:27,780 --> 02:53:30,340
So how do we relate to researchers?

1489
02:53:34,580 --> 02:53:42,100
Well, I think most of us mainly help researchers with a variety of questions when it comes to

1490
02:53:42,100 --> 02:53:52,500
programming, but we are mostly, I think we are not solving the scientific question, we are solving

1491
02:53:52,500 --> 02:53:58,740
the implementation of whatever they come up with, with their solution or enable them to

1492
02:53:59,940 --> 02:54:03,060
use that solution or make it available to others.

1493
02:54:03,060 --> 02:54:16,860
Exactly, so that to me at least is one of the issues with specific questions for specific

1494
02:54:16,860 --> 02:54:25,220
software where I would commonly say, ask an expert in your field, they have a much better

1495
02:54:25,220 --> 02:54:31,260
chance of having in-depth knowledge of, okay, these are the tools that are currently state

1496
02:54:31,260 --> 02:54:39,120
of the art when it comes to analyzing tools or analyzing data.

1497
02:54:39,120 --> 02:54:47,960
We can of course also search things, but we are not commonly using these tools ourselves

1498
02:54:47,960 --> 02:54:51,600
most of the time.

1499
02:54:51,600 --> 02:54:59,380
There might be projects where we get in connection and see things, and yeah, if we see that that

1500
02:54:59,380 --> 02:55:06,820
works well or is well documented or something we can sometimes make suggestions but in a general

1501
02:55:06,820 --> 02:55:17,780
principle they are specialized highly specialized software where we can help you get into it or

1502
02:55:18,340 --> 02:55:23,780
if you tell us that you need something or if people tell us that they need something to

1503
02:55:23,780 --> 02:55:28,260
to something done with a certain software or so,

1504
02:55:28,260 --> 02:55:31,220
we can probably set up a system that they can use,

1505
02:55:31,220 --> 02:55:33,180
a kind of building a small prototype

1506
02:55:33,180 --> 02:55:34,480
that they can then expand.

1507
02:55:35,700 --> 02:55:40,100
But as, yeah, on a more general level,

1508
02:55:40,100 --> 02:55:45,100
we are not the experts in the software, I would say.

1509
02:55:51,740 --> 02:55:52,940
Any other opinions?

1510
02:55:53,780 --> 02:56:04,860
Yeah, I'd say that throughout this course, you might get this impression that you start

1511
02:56:04,860 --> 02:56:10,320
with the coding, which is NumPy and Pandas and that, and it quite quickly goes into actually

1512
02:56:10,320 --> 02:56:15,020
what you're doing is doing library management and installing dependencies.

1513
02:56:15,020 --> 02:56:18,300
And that's, of course, where we usually help our users.

1514
02:56:18,300 --> 02:56:24,300
like, if you know about the scientific subject, you know, about the context of like context of

1515
02:56:24,300 --> 02:56:29,420
the functions you're calling, what, what does it mean to do a Markov chain or whatever?

1516
02:56:29,420 --> 02:56:34,460
Like, you know, a context of where, where do I use this? Like, I don't know, like,

1517
02:56:36,700 --> 02:56:42,620
genome splitting function or whatever, like, you, you know, the context of the function,

1518
02:56:42,620 --> 02:56:49,340
the mathematical context and the subject context. But we usually help with that annoying part,

1519
02:56:49,340 --> 02:56:56,780
which is like, okay, how can I get this working? And this is unfortunately a big part of the whole

1520
02:56:56,780 --> 02:57:06,540
field because there's so much available. And of course, everybody wants to utilize the tools

1521
02:57:06,540 --> 02:57:15,580
because if you've ever tried writing, for example, Fortran code, and then you get some solutions

1522
02:57:15,580 --> 02:57:20,860
out of it and you store it, then you have to think about, okay, how do I even visualize this?

1523
02:57:20,860 --> 02:57:25,740
How do I plot this? Because it's like a Fortran binary format or something. Nobody wants to do

1524
02:57:25,740 --> 02:57:31,340
that. Nobody wants to write their own data readers or CSV readers or that sort of stuff.

1525
02:57:31,340 --> 02:57:35,820
nobody wants to waste time on that. So you want to use already existing tools. But of course,

1526
02:57:36,540 --> 02:57:43,340
if you want to use the already existing tools, you encounter a lot of hiccups with those tools.

1527
02:57:43,340 --> 02:57:50,780
And that's where we usually jump in and help the users. We understand enough of the context

1528
02:57:50,780 --> 02:57:56,300
to understand what the tools, how are the tools are supposed to be used and that sort of stuff,

1529
02:57:56,300 --> 02:57:59,180
and what the user wants to do with the tools.

1530
02:57:59,180 --> 02:58:02,740
But usually, we don't know about the field that much.

1531
02:58:02,740 --> 02:58:07,180
We mainly know the general idea about it.

1532
02:58:07,180 --> 02:58:10,940
And then we can figure out how to apply those tools

1533
02:58:10,940 --> 02:58:12,980
to that specific case.

1534
02:58:17,340 --> 02:58:19,740
Yeah.

1535
02:58:19,740 --> 02:58:22,420
I like question 42.

1536
02:58:22,420 --> 02:58:25,340
Do you think Python will ever become outdated, replaced

1537
02:58:25,340 --> 02:58:30,460
by a different language, since some people seem to say that R

1538
02:58:30,460 --> 02:58:33,980
might not be used anymore in the near future.

1539
02:58:33,980 --> 02:58:36,100
I've put an answer in there.

1540
02:58:36,100 --> 02:58:38,620
I think it's possible, sure.

1541
02:58:38,620 --> 02:58:40,980
I don't think it's likely anywhere

1542
02:58:40,980 --> 02:58:49,260
in the foreseeable future, since the ecosystem has kind of

1543
02:58:49,260 --> 02:58:52,660
achieved a critical mass, provides

1544
02:58:52,660 --> 02:59:02,260
so much possibilities and has addressed the issues that the language has.

1545
02:59:02,260 --> 02:59:14,620
So all these bridging to other languages where you have a lot more efficient ways to do certain

1546
02:59:14,620 --> 02:59:21,140
and things, make the disadvantages somewhat less.

1547
02:59:23,780 --> 02:59:30,260
So like, let's say Python seems to have this really good balance

1548
02:59:30,260 --> 02:59:35,060
between power and user interface,

1549
02:59:35,060 --> 02:59:38,420
and also a way that it moves slow enough

1550
02:59:38,420 --> 02:59:42,780
they really think about how the language is developing.

1551
02:59:42,780 --> 02:59:49,460
It is being actively developed, so yeah, that obviously helps a lot.

1552
02:59:49,460 --> 02:59:57,300
So there is that one little design choice that it can't do multi-threading, but I mean

1553
02:59:57,300 --> 03:00:03,100
we make this ways to get around that and multi-threading happens in the libraries anyway, so it's not

1554
03:00:03,100 --> 03:00:04,260
really a big problem.

1555
03:00:04,260 --> 03:00:11,120
But yeah, the way I could see any language gets replaced is by the design issues becoming

1556
03:00:11,120 --> 03:00:16,600
problematic, or by a completely new paradigm becoming problematic.

1557
03:00:16,600 --> 03:00:17,600
Yeah.

1558
03:00:17,600 --> 03:00:23,400
Python has this kind of like a tendency of whatever, like people say, like if people

1559
03:00:23,400 --> 03:00:28,160
say that, okay, they don't like a feature in Python, like suddenly there's like a package

1560
03:00:28,160 --> 03:00:33,440
that somebody like implements that, like for example, like Python doesn't do static typing,

1561
03:00:33,440 --> 03:00:39,000
but nowadays people have written extensions that basically like for static typing wherever,

1562
03:00:39,000 --> 03:00:44,600
or they try to do type hints and they try to do typing as much as possible in Python.

1563
03:00:48,360 --> 03:00:54,040
Python is object-oriented and it's functional at the same time. There's people who like the

1564
03:00:54,040 --> 03:00:59,160
functional side and they write functional programming only and they try to implement

1565
03:00:59,160 --> 03:01:05,400
their stuff as functional programming and they find extensions that provide that. Then there's

1566
03:01:05,400 --> 03:01:10,040
people who like the object-oriented style and they write extensions that make that easier.

1567
03:01:10,040 --> 03:01:14,600
And then it's like, is it even the same language anymore? It's like a completely different dialect

1568
03:01:14,600 --> 03:01:23,720
of the same thing. And it's very hard to say like, yeah, what is the core language in Python

1569
03:01:23,720 --> 03:01:30,200
is so adaptable. And I think that's the main thing why it's so popular, that you can do all

1570
03:01:30,200 --> 03:01:36,200
kinds of stuff with them. There are libraries like, I mean, I guess TensorFlow is a great example.

1571
03:01:37,720 --> 03:01:45,960
It is essentially declarative. So Python is written to be, if you know, there are different

1572
03:01:45,960 --> 03:01:53,640
programming paradigms and Python is not written as a declarative language, but there are libraries

1573
03:01:53,640 --> 03:01:59,400
that actually make it declarative. So it can actually, depending on what library you use,

1574
03:01:59,400 --> 03:02:04,120
it can use a completely different programming paradigm. It's extensible enough.

1575
03:02:05,560 --> 03:02:11,480
And also the question about when people are asking there about R, I like R in many cases.

1576
03:02:12,040 --> 03:02:17,160
For statistics, I think R is a wonderful language. I wouldn't, again, do web scraping in R

1577
03:02:17,160 --> 03:02:23,240
necessarily or web servers or something like that. But again, it's not the forte of the language,

1578
03:02:23,240 --> 03:02:28,920
but it's very good at what it does. And I think the thing with the languages is same as

1579
03:02:28,920 --> 03:02:35,080
with natural languages? Are people actually using it in their everyday speech, basically?

1580
03:02:35,080 --> 03:02:41,880
Are people writing new stuff using that language? Are they creating new things or are they like

1581
03:02:41,880 --> 03:02:47,800
songs that some old person, like a hundred year old person remembers and that's the only

1582
03:02:47,800 --> 03:02:53,800
recollection that we have of a language and then we record it on a tape and then we remember that

1583
03:02:53,800 --> 03:03:00,520
we used to have this sort of a language, like languages are only alive when people use them.

1584
03:03:00,520 --> 03:03:06,440
Like in a normal, normal case, I think maybe some linguistics might be, might have a different

1585
03:03:06,440 --> 03:03:10,840
definition, but, but I think for programming language, the main thing is like who are,

1586
03:03:10,840 --> 03:03:16,680
who other people are using it? Not, not whether I'm using it correctly. If I have nobody to speak

1587
03:03:16,680 --> 03:03:23,080
with that language, it's not really helping me in any way. It's, it's about the whole like

1588
03:03:23,080 --> 03:03:28,600
community and ecosystem. And I think Python currently has a very healthy ecosystem. Of course,

1589
03:03:28,600 --> 03:03:33,320
there might be new things coming, but it's hard to tell. The timelines are so long.

1590
03:03:40,280 --> 03:03:44,760
Some questions about what to learn next. So there's not just the programming language,

1591
03:03:44,760 --> 03:03:50,600
but you might have seen a lot of what we're doing here is about how the programming language

1592
03:03:50,600 --> 03:03:56,680
interacts with the operating system, the data, things like that. And that's another good thing

1593
03:03:56,680 --> 03:04:02,760
to think about and follow up on, no matter what language you're using.

1594
03:04:08,040 --> 03:04:12,600
Question 45. If you want to learn Python or any other language, it's good to have a

1595
03:04:12,600 --> 03:04:18,040
problem and a deadline, and then you should try Advent of Code, just advertising Advent of Code.

1596
03:04:18,040 --> 03:04:22,560
But it's fun if you have time.

1597
03:04:26,960 --> 03:04:30,280
Should I do a little bit of wrap up of the course?

1598
03:04:30,280 --> 03:04:31,520
Yeah.

1599
03:04:31,520 --> 03:04:35,280
So there's an outro linked from the web page,

1600
03:04:35,280 --> 03:04:38,880
but it's not very up to date.

1601
03:04:38,880 --> 03:04:40,080
Maybe I'll share it anyway.

1602
03:04:44,600 --> 03:04:46,120
There, this is my screen.

1603
03:04:48,040 --> 03:05:00,040
So, there's many people that have helped made this part, not just the instructors, but others, and you can see the credits on the web page.

1604
03:05:00,040 --> 03:05:16,040
So, about organizations. Code Refinery is a publicly funded project by the Nordic e-Infrastructure Collaboration, which supports computational research, teaching, and software tools.

1605
03:05:16,040 --> 03:05:22,200
Our organization at Aalto University supports computational research here,

1606
03:05:22,920 --> 03:05:29,880
and a lot of the other instructors you saw from other institutions, they're very similar to us.

1607
03:05:29,880 --> 03:05:36,040
So basically, the idea is, like oftentimes in academia, you think, okay, I need to learn

1608
03:05:36,040 --> 03:05:43,960
everything myself. But in the real world, it's good to have other people you can work with as a team.

1609
03:05:43,960 --> 03:05:47,320
And if you don't have these kinds of computational experts

1610
03:05:47,320 --> 03:05:50,480
in your own group, you can come to people like us

1611
03:05:50,480 --> 03:05:52,440
and ask for help and advice.

1612
03:05:52,440 --> 03:05:54,400
So wherever you are, I'd recommend

1613
03:05:54,400 --> 03:05:59,000
you finding if there's these type of people there.

1614
03:05:59,000 --> 03:06:01,440
There are other future events.

1615
03:06:01,440 --> 03:06:04,080
So this is not updated since last year.

1616
03:06:04,080 --> 03:06:07,480
But actually, if you update the years,

1617
03:06:07,480 --> 03:06:09,800
it's actually pretty accurate.

1618
03:06:09,800 --> 03:06:14,480
So Code Refinery is a workshop on, basically,

1619
03:06:14,480 --> 03:06:18,160
version control and other software development practices.

1620
03:06:18,160 --> 03:06:22,440
So not about Python, but it's taught like this

1621
03:06:22,440 --> 03:06:25,400
and really good to take also.

1622
03:06:25,400 --> 03:06:28,160
Workflows course, this is written

1623
03:06:28,160 --> 03:06:30,120
we wanted to give it in 2022, and then we

1624
03:06:30,120 --> 03:06:33,760
wanted to give it in 2023, and we still haven't given it.

1625
03:06:33,760 --> 03:06:36,680
But maybe we should get on that.

1626
03:06:36,680 --> 03:06:39,040
I'm not sure if high performance data analysis will

1627
03:06:39,040 --> 03:06:41,440
be taught again.

1628
03:06:41,440 --> 03:06:47,560
And then also in June of 2023, in our university,

1629
03:06:47,560 --> 03:06:50,200
we have a course which is a kickstart

1630
03:06:50,200 --> 03:06:53,080
to scientific computing and high-performance computing.

1631
03:06:53,080 --> 03:06:56,520
And these courses, Code Refinery and this one,

1632
03:06:56,520 --> 03:06:59,000
are all taught just like we are here,

1633
03:06:59,000 --> 03:07:01,240
with the livestream format, code teaching,

1634
03:07:01,240 --> 03:07:06,640
and basically should be of this quality.

1635
03:07:06,640 --> 03:07:08,400
For announcements for many of these things,

1636
03:07:08,400 --> 03:07:15,600
subscribe to a Code Refinery newsletter. How to stay in touch? Well, you can find some social

1637
03:07:15,600 --> 03:07:21,280
media here. If you think that the kind of things we're talking about are what you're interested in,

1638
03:07:21,280 --> 03:07:29,920
possibly more interesting than the scientific side of things you do, or you like the science

1639
03:07:29,920 --> 03:07:35,840
but you also like the software more than you can do there, a research software engineer is the name

1640
03:07:35,840 --> 03:07:40,880
of the kind of people we are. So we do research, we do software, and we connect them.

1641
03:07:43,520 --> 03:07:50,000
If you would like to meet with more like-minded people like this, there's research software

1642
03:07:50,000 --> 03:07:56,640
engineer associations, which are of the people like us. In Nordics there is this one, but you

1643
03:07:56,640 --> 03:08:02,960
can find more in other places. Are there things to talk about working together?

1644
03:08:05,840 --> 03:08:10,160
So in the future,

1645
03:08:10,160 --> 03:08:13,320
these are some ideas for what to do.

1646
03:08:13,320 --> 03:08:16,880
Basically, you can join

1647
03:08:16,880 --> 03:08:18,800
the Code Refinery organization and

1648
03:08:18,800 --> 03:08:21,120
help us to put on courses like this.

1649
03:08:21,120 --> 03:08:22,980
So we really think we have

1650
03:08:22,980 --> 03:08:25,140
a pretty good teaching style here.

1651
03:08:25,140 --> 03:08:28,840
That's both accessible to a very large audience.

1652
03:08:28,840 --> 03:08:32,760
It's our information is reusable

1653
03:08:32,760 --> 03:08:36,280
since we have the videos and all of that.

1654
03:08:36,280 --> 03:08:39,720
It's also very interactive and fun to listen to.

1655
03:08:39,720 --> 03:08:44,040
If you would like to support this kind of thing,

1656
03:08:44,040 --> 03:08:45,720
please get in touch,

1657
03:08:45,720 --> 03:08:48,560
join Code Refinery, and at the very least,

1658
03:08:48,560 --> 03:08:52,040
tell people that we have this good way of teaching,

1659
03:08:52,040 --> 03:08:56,120
so we can try to spread it to other people.

1660
03:08:56,200 --> 03:08:58,700
With that being said, in the past,

1661
03:08:58,700 --> 03:09:00,800
we've had an after-party in Zoom,

1662
03:09:00,800 --> 03:09:06,200
So we would share the Zoom link that we are in right now

1663
03:09:06,200 --> 03:09:09,920
and allow everyone in the audience to join.

1664
03:09:12,880 --> 03:09:17,480
So I won't give it yet, but it's a possibility.

1665
03:09:20,560 --> 03:09:24,840
Should we put the feedback for today?

1666
03:09:24,840 --> 03:09:25,840
Oh, yes.

1667
03:09:25,840 --> 03:09:26,640
I forgot that.

1668
03:09:26,640 --> 03:09:36,160
And I will also send you a feedback, a more general anonymous feedback for the whole course

1669
03:09:36,160 --> 03:09:41,240
so that you could tell, for example, you know, what worked best, what needs improving or

1670
03:09:41,240 --> 03:09:43,680
what was missing.

1671
03:09:43,680 --> 03:09:46,640
And I was writing something in the notes that I forgot.

1672
03:09:46,640 --> 03:09:52,600
Oh yeah, that we also have a form where you can request future courses.

1673
03:09:52,600 --> 03:10:06,760
So I'm now I'm going to paste it there on it's coming so that you know if there is enough

1674
03:10:06,760 --> 03:10:18,220
volume of requests we can do all sorts of things I have to say that many of you when

1675
03:10:18,220 --> 03:10:24,820
you register, maybe 75% actually tick the box, please let me know about future courses.

1676
03:10:24,820 --> 03:10:30,500
So you will definitely receive more emails from me. And of course, you can always unsubscribe

1677
03:10:30,500 --> 03:10:40,100
Please give feedback if you hear this is important.

1678
03:10:56,860 --> 03:10:57,740
Is there any more?

1679
03:10:57,740 --> 03:11:01,660
Or should we call it the end?

1680
03:11:05,220 --> 03:11:09,260
Maybe we should call it the day and let people

1681
03:11:09,260 --> 03:11:13,340
join the Zoom after the streaming is over.

1682
03:11:13,340 --> 03:11:13,840
Yes.

1683
03:11:17,940 --> 03:11:21,340
Thank you, everyone.

1684
03:11:21,340 --> 03:11:23,540
Thank you to all.

1685
03:11:23,540 --> 03:11:26,060
You were a great audience.

1686
03:11:27,740 --> 03:11:35,580
And I think this was one of the best courses we've put on yet.

1687
03:11:35,580 --> 03:11:38,740
So thank you.

1688
03:11:38,740 --> 03:11:39,240
Bye.

1689
03:11:39,240 --> 03:11:39,740
Bye.

1690
03:11:39,740 --> 03:11:40,240
Bye.

1691
03:11:40,240 --> 03:11:41,780
Bye.

1692
03:11:57,740 --> 03:11:59,800
you

